#!/usr/bin/env sh
#
# debcomp - a configuration deployment system for Debian-based operating systems
#
# Version: 1.2.1 (10/03/2021)
#
# Copyright (c) 2021 10geek
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



### BEGIN COMMON FUNCTIONS

SIGNALS='HUP INT QUIT ILL ABRT FPE SEGV PIPE ALRM TERM USR1 USR2'
eval "signal_handler__register() { trap 'EXIT_CODE=\$?; trap '\\'\\'' \$SIGNALS; signal_handler EXIT' EXIT;$(
	LC_ALL=C awk -- 'BEGIN { for(i = 1; i < ARGC; i++) print "trap \47trap \47\134\47\134\47\47 $SIGNALS; signal_handler " ARGV[i] "; signal_handler__register\47 " ARGV[i] }' $SIGNALS
);}"

gets() { IFS= read -r "$1"; }
puts() { printf %s\\n "$1"; }
putsn() { printf %s "$1"; }
putv() { eval 'printf %s\\n "$'"$1"'"'; }
putvn() { eval 'printf %s "$'"$1"'"'; }
expr ":$(command -v printf)" : :/ > /dev/null && {
	puts() {
		cat <<- EOF
		$1
		EOF
	}
	putsn() {
		LC_ALL=C awk 'BEGIN { ORS = ""; if((getline) <= 0) exit 1; print $0 } { print "\n"; print $0 }' <<- EOF
		$1
		EOF
	}
	putv() {
		eval 'cat <<- EOF
		$'"$1"'
		EOF
		'
	}
	putvn() {
		eval 'LC_ALL=C awk '\''BEGIN { ORS = ""; if((getline) <= 0) exit 1; print $0 } { print "\n"; print $0 }'\'' <<- EOF
		$'"$1"'
		EOF
		'
	}
}

term_input() {
	unset -v ui_input
	while :; do
		ui_input=$(
			export ui_input
			dd bs=1 count=1 2>/dev/null | LC_ALL=C awk -- 'BEGIN {
				ARGC = 1
				if((getline) <= 0) {
					if(ARGV[1] + 0 && ENVIRON["ui_input"] == "") exit 0
					exit 1
				}
				gsub(/\0/, "")
				is_utf8 = (ENVIRON["ui_input"] == "" && $0 ~ /^[\300-\367]$/) || (ENVIRON["ui_input"] ~ /^([\300-\336\337]|[\340-\357][\200-\277]?|[\360-\367][\200-\277]?[\200-\277]?)$/ && $0 ~ /^[\200-\277]$/)
				if($0 == "") input = 10
				else if($0 ~ /^[\41-\176]$/ || is_utf8) input = $0
				else {
					for(i = 1; i < 33; i++) if($0 == sprintf("%c", i)) {
						if(i < 10) input = "0" i
						else input = i
						break
					}
					if(i == 33) for(i = 127; i < 256; i++) if($0 == sprintf("%c", i)) {
						input = i
						break
					}
				}
				if(ENVIRON["ui_input"] != "" && !is_utf8) ENVIRON["ui_input"] = ENVIRON["ui_input"] " "
				printf("%s", ENVIRON["ui_input"])
				print input
				if(ENVIRON["ui_input"] input ~ /^([\300-\367]|[\340-\367][\200-\277]|[\360-\367][\200-\277][\200-\277]|27( \[( \[| [0-9]( [0-9]( ;( [0-9])?)?| ;( [0-9])?)?)?| O( [0-9])?)?)$/) exit 1
			}' "$1"
		) && break
	done
}
ui_mode() {
	case $1 in
	on)
		[ -n "$ui_mode__stty_old_settings" ] && return 0
		{
			ui_mode__stty_old_settings=$(stty -g < /dev/tty) &&
			[ -n "$ui_mode__stty_old_settings" ] &&
			stty -icanon -echo < /dev/tty
		} || return 1
		printf '\33[?1049h\33[?1h\33=\33[?25l'
		;;
	off)
		[ -z "$ui_mode__stty_old_settings" ] && return 0
		stty "$ui_mode__stty_old_settings" < /dev/tty || return 1
		unset -v ui_mode__stty_old_settings
		printf '\33[?25h\33[0m\33[?1l\33>\n\33[?1049l'
		;;
	*) return 1;;
	esac
}
unset -v ui_mode__stty_old_settings
ui_callback() { :; }
ui() {
	ui_mode on || return 1
	unset -v ui_choice ui_event ui_input ui_menu_height_old ui_output ui_search ui_value_l ui_value_r ui_var_name
	ui_init=1
	ui_title=$1
	ui_description=$2
	ui_menu=$3
	ui_menu_cursor_pos=$4
	while :; do
		unset -v ui_action
		eval "$(stty -a < /dev/tty | awk 'BEGIN { w = h = 0 } {
			gsub(/[;=]/, " ")
			for(i = 1; i < NF; i++) {
				if($i == "rows") h = int($(++i) + 0)
				else if($i == "columns" || $i == "cols") w = int($(++i) + 0)
				if(w > 0 && h > 0) exit
			}
		} END {
			if(w < 1) w = 80
			if(h < 1) h = 24
			print "ui_stty_width=" w "; ui_stty_height=" h
		}')"
		if [ "$ui_event" = edit ] || [ "$ui_event" = search_edit ]; then
			eval "$(
			export ui_event ui_input ui_value_l ui_value_r
			LC_ALL=C awk -- '
			function shell_escape(_in) {
				gsub(/\0/, "", _in)
				gsub(/\47/, "\47\134\47\47", _in)
				return "\47" _in "\47"
			}
			BEGIN {
				non_word_chars = "][ \t\r\n\v\f/\\\\()\"\47:,.;<>~!@#$%^&*|+={}`?-"
				input = ENVIRON["ui_input"]
				value_l = ENVIRON["ui_value_l"]
				value_r = ENVIRON["ui_value_r"]
				l_changed = 0; r_changed = 0
				if(input ~ /^(32|[\41-\176]|[\300-\336\337][\200-\277]|[\340-\357][\200-\277][\200-\277]|[\360-\367][\200-\277][\200-\277][\200-\277])$/) {
					l_changed = 1
					if(input == "32") input = " "
					value_l = value_l input
				} else if(input == "27 O A" || input == "27 O B") {
					if(ENVIRON["ui_event"] == "search_edit")
						print "ui_value_l=$ui_search\nunset -v ui_value_r"
				} else if(input == "27 O D" || input == "02") {
					if(value_l == "") exit
					l_changed = r_changed = 1
					if(match(value_l, /[^\1-\177\300-\367]*$/) < 3) {
						value_r = value_l value_r
						value_l = ""
					} else {
						value_r = substr(value_l, RSTART - 1, RLENGTH + 1) value_r
						value_l = substr(value_l, 1, RSTART - 2)
					}
				} else if(input == "27 O C" || input == "06") {
					if(value_r == "") exit
					l_changed = r_changed = 1
					if(match(value_r, /^.[^\1-\177\300-\367]*[\1-\177\300-\367]/)) {
						value_l = value_l substr(value_r, 1, RLENGTH - 1)
						value_r = substr(value_r, RLENGTH)
					} else {
						value_l = value_l value_r
						value_r = ""
					}
				} else if(input == "27 [ 1 ; 5 D") {
					if(value_l == "") exit
					l_changed = r_changed = 1
					if(match(value_l, "[^" non_word_chars "]*[" non_word_chars "]*$") < 2) {
						value_r = value_l value_r
						value_l = ""
					} else {
						value_r = substr(value_l, RSTART, RLENGTH) value_r
						value_l = substr(value_l, 1, RSTART - 1)
					}
				} else if(input == "27 [ 1 ; 5 C") {
					if(value_r == "") exit
					l_changed = r_changed = 1
					if(match(value_r, "^[" non_word_chars "]*[^" non_word_chars "]+[" non_word_chars "]")) {
						value_l = value_l substr(value_r, 1, RLENGTH - 1)
						value_r = substr(value_r, RLENGTH)
					} else {
						value_l = value_l value_r
						value_r = ""
					}
				} else if(input == "27 O H" || input == "27 [ 1 ~" || input == "01") {
					if(value_l == "") exit
					l_changed = r_changed = 1
					value_r = value_l value_r
					value_l = ""
				} else if(input == "27 O F" || input == "27 [ 4 ~" || input == "05") {
					if(value_r == "") exit
					l_changed = r_changed = 1
					value_l = value_l value_r
					value_r = ""
				} else if(input == "127" || input == "08") {
					if(sub(/.[^\1-\177\300-\367]*$/, "", value_l)) l_changed = 1
				} else if(input == "27 [ 3 ~" || input == "04") {
					if(sub(/^.[^\1-\177\300-\367]*/, "", value_r)) r_changed = 1
				} else if(input == "23") {
					l_changed = 1
					sub("[^" non_word_chars "]*[" non_word_chars "]*$", "", value_l)
				} else if(input == "27 [ 3 ; 5 ~") {
					r_changed = 1
					sub("^[" non_word_chars "]*[^" non_word_chars "]*", "", value_r)
				} else if(input == "21") {
					l_changed = 1
					value_l = ""
				} else if(input == "11") {
					r_changed = 1
					value_r = ""
				} else if(input == "10") {
					if(ENVIRON["ui_event"] == "search_edit") print "ui_event=search_edit_complete"
					else print "ui_event=edit_complete"
				} else if(input == "31" || input == "27 27")
					print "printf \47\\33[?25l\47\nunset -v ui_event"
				if(l_changed) print "ui_value_l=" shell_escape(value_l)
				if(r_changed) print "ui_value_r=" shell_escape(value_r)
			}')"
		else
			case $ui_input in
			'27 O H'|'27 [ 1 ~') ui_action=nav_home;;
			'27 O F'|'27 [ 4 ~') ui_action=nav_end;;
			'10'|'32') ui_action=select;;
			'N'|'27 O 2 R'|'27 [ 2 8 ~') ui_action=search_prev;;
			'n'|'27 O R'|'27 [ [ C') ui_action=search_next;;
			'/'|'06') ui_action=search_edit;;
			'q'|'127'|'27 27') ui_event=exit;;
			esac
		fi
		case $ui_input in
		'27 O A') ui_action=nav_up;;
		'27 O B') ui_action=nav_down;;
		'27 [ 5 ~') ui_action=nav_page_up;;
		'27 [ 6 ~') ui_action=nav_page_down;;
		'27 [ Z'|'27 [ 1 ; 5 A') ui_action=nav_prev_selectable;;
		'09'|'27 [ 1 ; 5 B') ui_action=nav_next_selectable;;
		esac
		[ -n "$ui_action" ] && [ "$ui_event" = edit ] && ui_event=edit_complete
		ui_callback "$@"
		{ [ "$ui_event" = select ] || [ "$ui_event" = exit ]; } && break
		unset -v ui_choice ui_input
		if [ "$ui_event" = edit ] || [ "$ui_event" = search_edit ]; then
			unset -v ui_action
		else
			case $ui_event in
			edit_complete)
				printf '\33[?25l'
				expr "$ui_var_name" : '[A-Za-z_][A-Za-z0-9_]*$' > /dev/null &&
					eval "$ui_var_name=\$ui_value_l\$ui_value_r"
			;;
			search_edit_complete)
				printf '\33[?25l'
				ui_search=$ui_value_l$ui_value_r
				ui_action=search_next
			;;
			esac
			unset -v ui_event ui_var_name
		fi
		ui_output=$(
		export ui_action ui_description ui_event ui_menu_cursor_pos ui_menu_height_old ui_search ui_title ui_value_l ui_value_r
		eval "$(putv ui_menu | LC_ALL=C awk '{
			if(sub(/^[ \t]*[cimpr]/, "") && match($0, /^[A-Za-z_][A-Za-z0-9_]*/))
				print "export " substr($0, RSTART, RLENGTH)
		}')"
		awkprog='
		function mblength(string) {
			gsub(/[^\1-\177\300-\367]/, "", string)
			return length(string)
		}
		function mbchrpos(string, i,    l, char_ord) {
			i += 0; l = length(string)
			if(i < 1 || i > l) {
				RSTART = 0; RLENGTH = -1
				return 0
			}
			RLENGTH = 0
			for(RSTART = 1; RSTART <= l; RSTART++) {
				char_ord = ord__trtab[substr(string, RSTART, 1)]
				if((char_ord < 128 || char_ord > 191) && --i == 0) {
					if(char_ord < 128) RLENGTH = 1
					else if(char_ord < 224) RLENGTH = 2
					else if(char_ord < 240) RLENGTH = 3
					else if(char_ord < 248) RLENGTH = 4
					else RLENGTH = 1
					break
				}
			}
			if(!RLENGTH) {
				RSTART = 0; RLENGTH = -1
			} else if(RSTART + RLENGTH - 1 > l) RLENGTH = 1
			else if(RLENGTH > 1) {
				for(i = RSTART + 1; i < RSTART + RLENGTH; i++) {
					char_ord = ord__trtab[substr(string, i, 1)]
					if(char_ord < 128 || char_ord > 191) {
						RLENGTH = 1
						break
					}
				}
			}
			return RSTART
		}
		function wordwrap(string, width, fill_space, max_lines, add_ellipsis,    out, i, lines, string_lines_count, line_length, line, OLD_RSTART, OLD_RLENGTH) {
			OLD_RSTART = RSTART; OLD_RLENGTH = RLENGTH
			if(width < 1) width = 1
			if(max_lines <= 0) max_lines = 0
			out = ""
			string_lines_count = split(string, lines, "\n")
			if(!string_lines_count) {
				string_lines_count = 1
				lines[1] = ""
			}
			__wordwrap__lines_count = 0
			for(i = 1; i <= string_lines_count; i++) {
				if(i != 1) out = out "\n"
				while(mbchrpos(lines[i], width + 1)) {
					__wordwrap__lines_count++
					if(max_lines > 0 && __wordwrap__lines_count == max_lines) max_lines = -1
					line_length = RSTART - 1
					line = substr(lines[i], 1, line_length + RLENGTH)
					if(max_lines == -1 && add_ellipsis) {
						mbchrpos(line, width - 1)
						if(RSTART) match(substr(line, 1, RSTART - 1), / +[^ ]*$/)
					} else match(line, / [^ ]*$/)
					if(RSTART) {
						line = substr(line, 1, RSTART - 1)
						if(max_lines == -1 && add_ellipsis) line = line "..."
						else sub(/ *$/, "", line)
						if(fill_space) {
							line_length = mblength(line)
							line = line sprintf("%" (width - line_length) "s", "")
						}
						if(max_lines != -1) {
							lines[i] = substr(lines[i], RSTART + 1)
							sub(/^ */, "", lines[i])
						}
					} else {
						if(max_lines == -1 && add_ellipsis) {
							mbchrpos(line, width - 3)
							if(RSTART) line = substr(line, 1, RSTART + RLENGTH - 1) "..."
							else line = "..."
						} else line = substr(lines[i], 1, line_length)
						if(max_lines != -1) lines[i] = substr(lines[i], line_length + 1)
					}
					out = out line
					if(max_lines == -1) { break }
					if(lines[i] != "") out = out "\n"
				}
				if(max_lines != -1) {
					__wordwrap__lines_count++
					if(max_lines > 0 && __wordwrap__lines_count == max_lines) {
						max_lines = -1
						if(add_ellipsis && i != string_lines_count) {
							line_length = mblength(lines[i])
							if(width - line_length > 2) lines[i] = lines[i] "..."
							else {
								mbchrpos(lines[i], width - 2)
								if(RSTART && match(substr(lines[i], 1, RSTART + RLENGTH - 1), / +[^ ]*$/)) lines[i] = substr(lines[i], 1, RSTART - 1) "..."
								else {
									mbchrpos(lines[i], width - 3)
									if(RSTART) lines[i] = substr(lines[i], 1, RSTART + RLENGTH - 1) "..."
									else lines[i] = "..."
								}
							}
						}
					}
					if(fill_space) {
						line_length = mblength(lines[i])
						lines[i] = lines[i] sprintf("%" (width - line_length) "s", "")
					}
					out = out lines[i]
				}
				if(max_lines == -1) { break }
			}
			RSTART = OLD_RSTART; RLENGTH = OLD_RLENGTH
			return out
		}
		function filter_printable(string,    i, out, replaced_chars_count, OLD_RSTART, OLD_RLENGTH) {
			OLD_RSTART = RSTART; OLD_RLENGTH = RLENGTH
			out = ""
			gsub(/\t/, "    ", string)
			gsub(/\0/, "", string)
			while(string != "") {
				if(!match(string, /([\n\40-\176]|[\303-\310\312\313\320\321\332][\200-\277]|\302[\240-\277]|\311[\200\201\220-\277]|\315[\264\265\272\276]|\316[\204-\212\214\216-\241\243-\277]|\317[\200-\216\220-\277]|\322[\200-\202\212-\277]|\323[\200-\216\220-\271]|\324[\200-\217\261-\277]|\325[\200-\226]|\325[\231-\237\241-\277]|\326[\200-\207\211-\212\276]|\327[\200\203\206\220-\252\260-\264]|\330[\213-\217\233\236\237\241-\272]|\331[\200-\212\240-\257\261-\277]|\333[\200-\225\245\246\251\256-\277]|\334[\200-\215\220\222-\257]|\335[\215-\255]|\336[\200-\245\261]|\340(\244[\203-\271\275-\277]|\245[\200\211-\214\220\230-\241\244-\260\275]|\246[\202\203\205-\214\217\220\223-\250\252-\260\262\266-\271\275-\277]|\247[\200\207\210\213\214\216\227\234\235\237-\241\246-\272]|\250[\203\205-\212\217\220\223-\250\252-\260\262\263\265\266\270\271\276\277]|\251[\200\231-\234\236\246-\257\262-\264]|\252[\203\205-\215\217-\221\223-\250\252-\260\262\263\265-\271\275-\277]|\253[\200\211\213\214\220\240\241\246-\257\261]|\254[\202\203\205-\214\217\220\223-\250\252-\260\262\263\265-\271\275\276]|\255[\200\207\210\213\214\227\234\235\237-\241\246-\261]|\256[\203\205-\212\216-\220\222-\225\231\232\234\236\237\243\244\250-\252\256-\271\276\277]|\257[\201\202\206-\210\212-\214\227\246-\272]|\260[\201-\203\205-\214\216-\220\222-\250\252-\263\265-\271]|\261[\201-\204\240\241\246-\257]|\262[\202\203\205-\214\216-\220\222-\250\252-\263\265-\271\275\276]|\263[\200-\204\207\210\212\213\225\226\236\240\241\246-\257]|\264[\202\203\205-\214\216-\220\222-\250\252-\271\276\277]|\265[\200\206-\210\212-\214\227\240-\241\246-\257]|\266[\202\203\205-\226\232-\261\263-\273\275]|\267[\200-\206\217-\221\230-\237\262-\264]|\270[\201-\260\262\263\277]|\271[\200-\206\217-\233]|\272[\201\202\204\207\210\212\215\224-\227\231-\237\241-\243\245\247\252\253\255-\260\262\263\275]|\273[\200-\204\206\220-\231\234\235]|\274[\200-\227\232-\264\266\270\272-\277]|\275[\200-\207\211-\252\277]|\276[\205\210-\213\276\277]|\277[\200-\205\207-\214\217-\221])|\341(\200[\200-\241\243-\247\251\252\254\261\270]|\201[\200-\227]|\202\240|\203[\205\220-\274]|\210\200|\211[\210\212-\215\220-\226\230\232-\235\240-\277]|\212[\200-\210\212-\215\220-\260\262-\265\270-\276]|\213[\200\202-\205\210-\226\230-\277]|\214[\200-\220\222-\225\230-\277]|\215[\200-\232\240-\274]|\216[\200-\231\240-\277]|\217[\200-\264]|\220\201|\231\266|\220\201|\231\266|\232[\200-\234\240-\277]|\233[\200-\260]|\234[\200-\214\216-\221\240-\261\265\266]|\235[\200-\221\240-\254\256-\260]|\236[\200-\263\266\276\277]|\237[\200-\205\207\210\224-\234\240-\251\260-\271]|\240[\200-\212\216\220-\231\240-\277]|\241[\200-\267]|\242[\200-\250]|\244[\200-\234\243-\246\251-\253\260\261\263-\270]|\245[\200\204-\255\260-\264]|\246[\200-\251\260-\277]|\247[\200-\211\220-\231\236-\277]|\250[\200-\226\231-\233\236\237]|[\264-\266\270\271][\200-\277]|\272[\200-\233\240-\277]|\273[\200-\271]|\274[\200-\225\230-\235\240-\277]|\275[\200-\205\210-\215\220-\227\231\233\235\237-\275]|\276[\200-\264\266-\277]|\277[\200-\204\206-\223\226-\233\235-\257\262-\264\266-\276])|\342([\204\207-\213\215\216\222-\231\240-\253\262][\200-\277]|\200[\200-\212\220-\251\257-\277]|\201[\200-\237\260\261\264-\277]|\202[\200-\216\220-\224\240-\265]|\205[\200-\214\223-\277]|\206[\200-\203\220-\277]|\214[\200-\250\253-\277]|\217[\200-\233]|\220[\200-\246]|\221[\200-\212\240-\277]|\232[\200-\234\240-\261]|\234[\201-\204\206-\211\214-\247\251-\277]|\235[\200-\213\215\217-\222\226\230-\236\241-\277]|\236[\200-\224\230-\257\261-\276]|\237[\200-\206\220-\253\260-\277]|\254[\200-\223]|\260[\200-\256\260-\277]|\261[\200-\236]|\263[\200-\252\271-\277]|\264[\200-\245\260-\277]|\265[\200-\245\257]|\266[\200-\226\240-\246\250-\256\260-\266\270-\276]|\267[\200-\206\210-\216\220-\226\230-\236]|\270[\200-\227\234-\235])|\352(\234[\200-\226]|\240[\200-\205\207-\212\214-\244\247-\253])|\356\200\200|\357(\243\277|\254[\200-\206\223-\227\235\237-\266\270-\274\276]|\255[\200\201\203\204\206-\277]|\256[\200-\261]|\257[\223-\277]|[\260-\264][\200-\277]|\265[\220-\277]|\266[\200-\217\222-\277]|\267[\200-\207\260-\275]|\271[\260-\264\266]|\273[\200-\274]|\275[\241-\277]|\276[\200-\276]|\277[\202-\207\212-\217\222-\227\232-\234\250-\256\274\275]))+/))
					replaced_chars_count = mblength(string)
				else if(RSTART > 1)
					replaced_chars_count = mblength(substr(string, 1, RSTART - 1))
				if(RSTART != 1) {
					for(i = 0; i < replaced_chars_count; i++)
						out = out "\357\277\275"
					if(!RSTART) { break }
				}
				out = out substr(string, RSTART, RLENGTH)
				string = substr(string, RSTART + RLENGTH)
			}
			RSTART = OLD_RSTART; RLENGTH = OLD_RLENGTH
			return out
		}
		function shell_escape(string) {
			gsub(/\0/, "", string)
			gsub(/\n/, "\n.", string)
			gsub(/\47/, "\47\134\47\47", string)
			return "\47" string "\47"
		}
		function is_checked(menu_index) {
			if(menu_items_type[menu_index] == "m") {
				if(!(menu_items_vars[menu_index] in multiselect_values)) {
					multiselect_values[menu_items_vars[menu_index]] = ""
					_tmp_count = split(ENVIRON[menu_items_vars[menu_index]], _tmp, "\n")
					for(_i = 1; _i <= _tmp_count; _i++)
						multiselect_values[menu_items_vars[menu_index] ":" _tmp[_i]] = ""
				}
				if(menu_index in menu_items_values)
					return menu_items_vars[menu_index] ":" menu_items_values[menu_index] in multiselect_values
				return menu_items_vars[menu_index] ":" menu_items[menu_index] in multiselect_values
			} else if(menu_items_type[menu_index] == "c")
				return (ENVIRON[menu_items_vars[menu_index]] ~ /^[1-9][0-9]*$/) == (!(menu_index in menu_items_values) || menu_items_values[menu_index] ~ /^[1-9][0-9]*$/)
			else if(menu_items_type[menu_index] == "r") {
				if(menu_index in menu_items_values)
					return ENVIRON[menu_items_vars[menu_index]] == menu_items_values[menu_index]
				return ENVIRON[menu_items_vars[menu_index]] == menu_items[menu_index]
			} else return -1
		}
		BEGIN {
			ARGC = 1
			for(i = 1; i < 256; i++) ord__trtab[sprintf("%c", i)] = i
			term_w = ARGV[1] + 0
			term_h = ARGV[2] + 0
			action = ENVIRON["ui_action"]
			event = ENVIRON["ui_event"]
			menu_height_old = ENVIRON["ui_menu_height_old"] + 0
			menu_cursor_pos = ENVIRON["ui_menu_cursor_pos"] + 0
			print_at_end = ""
			menu_items_count = 0
		} {
			menu_items_count++
			sub(/^[ \t]+/, "")
			if(match($0, /^[cimpr][A-Za-z_][A-Za-z0-9_]*/)) {
				menu_items_type[menu_items_count] = substr($0, 1, 1)
				menu_items_vars[menu_items_count] = substr($0, RSTART + 1, RLENGTH - 1)
				menu_items[menu_items_count] = substr($0, RSTART + RLENGTH + 1)
			} else if(match($0, /^[bqht]/)) {
				menu_items_type[menu_items_count] = substr($0, 1, 1)
				menu_items[menu_items_count] = substr($0, 2)
			} else {
				menu_items_count--
				if(!menu_items_count) next
				if(sub(/^v/, "")) {
					if(menu_items_type[menu_items_count] != "m" && menu_items_count in menu_items_values)
						menu_items_values[menu_items_count] = menu_items_values[menu_items_count] "\n" $0
					else
						menu_items_values[menu_items_count] = $0
				} else if(sub(/^d/, "")) {
					if(menu_items_count in menu_items_desc_raw)
						menu_items_desc_raw[menu_items_count] = menu_items_desc_raw[menu_items_count] "\n" $0
					else
						menu_items_desc_raw[menu_items_count] = $0
				} else if(sub(/^s/, "")) {
					if(ENVIRON["ui_menu_cursor_pos"] == "") menu_cursor_pos = menu_items_count
				}
			}
		} END {
			if(!menu_items_count) {
				menu_items_count = split(wordwrap(filter_printable(ENVIRON["ui_description"]), term_w - 2, 0, 0, 0), _tmp, "\n")
				for(i = 1; i <= menu_items_count; i++) {
					menu_items[i] = _tmp[i]
					menu_items_type[i] = "t"
				}
				default_desc = ENVIRON["ui_description"] = ""
				desc_height = default_desc_height = 0
			} else if(ENVIRON["ui_description"] != "") {
				default_desc = wordwrap(filter_printable(ENVIRON["ui_description"]), term_w, 1, 0, 0)
				desc_height = default_desc_height = __wordwrap__lines_count
			} else {
				default_desc = ""
				desc_height = default_desc_height = 0
			}
			if(action == "nav_up") menu_cursor_pos--
			else if(action == "nav_down") menu_cursor_pos++
			else if(action == "nav_page_up") menu_cursor_pos -= int(menu_height_old / 2)
			else if(action == "nav_page_down") menu_cursor_pos += int(menu_height_old / 2)
			else if(action == "nav_home") menu_cursor_pos = 1
			else if(action == "nav_end") menu_cursor_pos = menu_items_count
			else if(action == "nav_prev_selectable") {
				for(i = menu_cursor_pos - 1; i != menu_cursor_pos; i--) {
					if(i < 1) {
						if(menu_cursor_pos == menu_items_count) { break }
						i = menu_items_count
					}
					if(menu_items_type[i] != "h" && menu_items_type[i] != "t") {
						menu_cursor_pos = i
						break
					}
				}
			} else if(action == "nav_next_selectable") {
				for(i = menu_cursor_pos + 1; i != menu_cursor_pos; i++) {
					if(i > menu_items_count) {
						if(menu_cursor_pos == 1) { break }
						i = 1
					}
					if(menu_items_type[i] != "h" && menu_items_type[i] != "t") {
						menu_cursor_pos = i
						break
					}
				}
			} else if(action == "select" && menu_cursor_pos in menu_items) {
				if(menu_items_type[menu_cursor_pos] == "i" || menu_items_type[menu_cursor_pos] == "p") {
					print ".ui_event=edit\n.ui_var_name=" menu_items_vars[menu_cursor_pos] "\n.ui_value_l=$" menu_items_vars[menu_cursor_pos] "\n.ui_value_r=\47\47\n.printf \47\\33[?25h\47\n.continue"
					exit
				} else if(menu_items_type[menu_cursor_pos] == "m") {
					if(menu_cursor_pos in menu_items_values) menu_item_value = menu_items_values[menu_cursor_pos]
					else menu_item_value = menu_items[menu_cursor_pos]
					if(is_checked(menu_cursor_pos)) {
						delete multiselect_values[menu_items_vars[menu_cursor_pos] ":" menu_item_value]
						is_first = 1
						for(i = 1; i <= _tmp_count; i++) {
							if(_tmp[i] == menu_item_value) { continue }
							if(is_first) {
								is_first = 0
								if(_tmp[i] == "") menu_item_var_value = "\n"
								else menu_item_var_value = _tmp[i]
							} else if(_tmp[i] == "") {
								if(menu_item_var_value !~ /^\n/)
									menu_item_var_value = "\n" menu_item_var_value
							} else
								menu_item_var_value = menu_item_var_value "\n" _tmp[i]
						}
					} else {
						multiselect_values[menu_items_vars[menu_cursor_pos] ":" menu_item_value] = ""
						if(ENVIRON[menu_items_vars[menu_cursor_pos]] == "") {
							if(menu_item_value == "") menu_item_var_value = "\n"
							else menu_item_var_value = menu_item_value
						} else if(menu_item_value == "") {
							if(menu_item_var_value !~ /^\n/)
								menu_item_var_value = "\n" ENVIRON[menu_items_vars[menu_cursor_pos]]
						} else
							menu_item_var_value = ENVIRON[menu_items_vars[menu_cursor_pos]] "\n" menu_item_value
					}
					print ".ui_var_name=" menu_items_vars[menu_cursor_pos] "\n." menu_items_vars[menu_cursor_pos] "=" shell_escape(menu_item_var_value) "\n.continue"
					exit
				} else if(menu_items_type[menu_cursor_pos] == "c") {
					print ".ui_var_name=" menu_items_vars[menu_cursor_pos] "\n." menu_items_vars[menu_cursor_pos] "=" (is_checked(menu_cursor_pos) != (!(menu_cursor_pos in menu_items_values) || menu_items_values[menu_cursor_pos] ~ /^[1-9][0-9]*$/)) "\n.continue"
					exit
				} else if(menu_items_type[menu_cursor_pos] == "r") {
					print ".ui_var_name=" menu_items_vars[menu_cursor_pos] "\n." menu_items_vars[menu_cursor_pos] "=" shell_escape(menu_cursor_pos in menu_items_values ? menu_items_values[menu_cursor_pos] : menu_items[menu_cursor_pos]) "\n.continue"
					exit
				} else if(menu_items_type[menu_cursor_pos] == "b") {
					if(menu_cursor_pos in menu_items_values)
						print ".ui_choice=" shell_escape(menu_items_values[menu_cursor_pos])
					else
						print ".ui_choice=" shell_escape(menu_items[menu_cursor_pos])
					print ".ui_var_name=ui_choice\n.ui_event=select\n.continue"
					exit
				} else if(menu_items_type[menu_cursor_pos] == "q") {
					print ".ui_event=exit\n.continue"
					exit
				}
			} else if(action == "search_prev") {
				if(ENVIRON["ui_search"] != "") {
					search_text = tolower(ENVIRON["ui_search"])
					for(i = menu_cursor_pos - 1; i != menu_cursor_pos; i--) {
						if(i < 1) {
							if(menu_cursor_pos == menu_items_count) { break }
							i = menu_items_count
						}
						if(index(tolower(menu_items[i] (menu_items_type[i] == "i" ? " " ENVIRON[menu_items_vars[i]] : "")), search_text)) {
							menu_cursor_pos = i
							break
						}
					}
				}
			} else if(action == "search_next") {
				if(ENVIRON["ui_search"] != "") {
					search_text = tolower(ENVIRON["ui_search"])
					for(i = menu_cursor_pos + 1; i != menu_cursor_pos; i++) {
						if(i > menu_items_count) {
							if(menu_cursor_pos == 1) { break }
							i = 1
						}
						if(index(tolower(menu_items[i] (menu_items_type[i] == "i" ? " " ENVIRON[menu_items_vars[i]] : "")), search_text)) {
							menu_cursor_pos = i
							break
						}
					}
				}
			} else if(action == "search_edit") {
				event = "search_edit"
				ENVIRON["ui_value_l"] = ""
				ENVIRON["ui_value_r"] = ""
				print ".ui_event=search_edit\n.unset -v ui_value_l ui_value_r"
				print_at_end = "\33[?25h"
			}
			if(menu_cursor_pos < 1) menu_cursor_pos = 1
			else if(menu_cursor_pos > menu_items_count) menu_cursor_pos = menu_items_count
			for(i in menu_items_desc_raw) {
				menu_items_desc[i] = wordwrap(filter_printable(menu_items_desc_raw[i]), term_w, 1, 0, 0)
				menu_items_desc_height[i] = __wordwrap__lines_count
				if(__wordwrap__lines_count > desc_height) desc_height = __wordwrap__lines_count
			}
			if(ENVIRON["ui_title"] == "") title_height = 0
			else {
				title = wordwrap(filter_printable(ENVIRON["ui_title"]), term_w, 1, 0, 0)
				title_height = __wordwrap__lines_count
			}
			if(desc_height) {
				if(menu_cursor_pos in menu_items_desc) {
					desc = menu_items_desc[menu_cursor_pos]
					desc_raw = menu_items_desc_raw[menu_cursor_pos]
					desc_text_height = menu_items_desc_height[menu_cursor_pos]
				} else {
					desc = default_desc
					desc_raw = ENVIRON["ui_description"]
					desc_text_height = default_desc_height
				}
			}
			menu_height = menu_items_count
			additional_height = 2
			total_height = title_height + desc_height + menu_height + additional_height
			if(total_height < term_h) menu_height += term_h - total_height
			else if(total_height > term_h) {
				menu_height -= total_height - term_h
				total_height -= total_height - term_h
				if(menu_height < 3) {
					total_height += 3 - menu_height
					menu_height = 3
				}
				if(title_height && total_height > term_h) {
					old_title_height = title_height
					title_height -= total_height - term_h
					total_height -= total_height - term_h
					if(title_height < 1) {
						total_height += 1 - title_height
						title_height = 1
					}
					if(title_height != old_title_height)
						title = wordwrap(filter_printable(ENVIRON["ui_title"]), term_w, 1, title_height, 1)
				}
				if(desc_height && total_height > term_h) {
					old_desc_height = desc_height
					desc_height -= total_height - term_h
					total_height -= total_height - term_h
					if(desc_height < 1) {
						total_height += 1 - desc_height
						desc_height = 1
					}
					if(desc_height < desc_text_height) {
						desc_text_height = desc_height
						desc = wordwrap(filter_printable(desc_raw), term_w, 1, desc_height, 1)
					}
				}
			}
			scroll_total = menu_items_count - menu_height
			if(scroll_total < 0) scroll_total = 0
			scroll_offset = menu_cursor_pos - sprintf("%.0f", menu_height / 2)
			if(menu_height + scroll_offset > menu_items_count)
				scroll_offset = menu_items_count - menu_height
			if(scroll_offset < 0) scroll_offset = 0
			if(menu_height >= menu_items_count) scrollbar_height = 0
			else {
				scrollbar_height = sprintf("%.0f", menu_height * (menu_height / menu_items_count)) + 0
				if(!scrollbar_height) scrollbar_height = 1
				scrollbar_offset = sprintf("%.0f", (menu_height - scrollbar_height) * scroll_offset / scroll_total) + 0
			}
			print ".ui_menu_height_old=" menu_height
			print ".ui_menu_cursor_pos=" menu_cursor_pos
			print ""
			if(title_height) printf("\33]0;%s\007", wordwrap(filter_printable(ENVIRON["ui_title"]), 128, 0, 1, 1))
			printf("\33[0m\33[1;1H")
			if(title_height) printf("\33[1;37;44m%s\n", title)
			if(desc_height) {
				printf("\33[0;30;47m")
				if(desc_text_height) print desc
				for(i = desc_text_height; i < desc_height; i++) printf("%" term_w "s\n", "")
			}
			printf("\33[0;30;47m\342\224\214")
			for(i = 2; i < term_w; i++) printf("\342\224\200")
			printf("\33[1;37;47m\342\224\220\n")
			for(i = 1; i <= menu_height; i++) {
				menu_index = i + scroll_offset
				printf("\33[0;30;47m\342\224\202")
				if(menu_index <= menu_items_count) {
					if(menu_index == menu_cursor_pos && menu_items_type[menu_index] !~ /^[ipht]$/) printf("\33[1;37;44m")
					if(menu_items_type[menu_index] == "i" || menu_items_type[menu_index] == "p") {
						if(menu_items[menu_index] == "") {
							label_length = 0
							field_width = term_w - 3
						} else {
							label = wordwrap(filter_printable(menu_items[menu_index]), term_w - 7, 0, 1, 1)
							label_length = mblength(label)
							field_width = term_w - label_length - 4
							if(field_width < 3) field_width = 3
							if(label_length + field_width + 3 > term_w) {
								label_length = 0
								field_width = term_w - 3
							}
						}
						if(field_width < 3) field_width = 3
						if(menu_index == menu_cursor_pos && event == "edit") {
							if(menu_items_type[menu_index] == "p") {
								gsub(/./, "*", ENVIRON["ui_value_l"])
								gsub(/./, "*", ENVIRON["ui_value_r"])
							} else {
								gsub(/\n/, "\357\277\275", ENVIRON["ui_value_l"])
								gsub(/\n/, "\357\277\275", ENVIRON["ui_value_r"])
								ENVIRON["ui_value_l"] = filter_printable(ENVIRON["ui_value_l"])
								ENVIRON["ui_value_r"] = filter_printable(ENVIRON["ui_value_r"])
							}
							field_cursor_pos = mblength(ENVIRON["ui_value_l"]) + 1
							value = ENVIRON["ui_value_l"] ENVIRON["ui_value_r"]
							value_length = field_cursor_pos + mblength(ENVIRON["ui_value_r"]) - 1
							field_offset = field_cursor_pos - sprintf("%.0f", field_width / 2)
							if(field_offset + field_width > value_length) {
								field_offset = value_length - field_width
								if(field_cursor_pos == value_length + 1) field_offset++
							}
							if(field_offset < 0) field_offset = 0
							print_at_end = print_at_end "\33[" title_height + desc_height + i + 1 ";" (label_length ? label_length + 1 : 0) + field_cursor_pos - field_offset + 1 "H"
						} else {
							if(menu_items_type[menu_index] == "p") {
								value = ENVIRON[menu_items_vars[menu_index]]
								gsub(/./, "*", value)
							} else {
								value = filter_printable(ENVIRON[menu_items_vars[menu_index]])
								gsub(/\n/, "\357\277\275", value)
							}
							value_length = mblength(value)
							field_cursor_pos = 0
							field_offset = 0
						}
						if(field_offset) value = substr(value, mbchrpos(value, field_offset + 1))
						if(field_offset + field_width < value_length) value = substr(value, 1, mbchrpos(value, field_width + 1) - 1)
						if(label_length) {
							if(menu_index == menu_cursor_pos) printf("\33[0;30;46m")
							printf("%s ", label)
						}
						printf("\33[" (menu_index == menu_cursor_pos ? 1 : 0) ";37;44m%s", value)
						for(j = field_offset + field_width; j > value_length; j--) printf("_")
						printf("\33[4" (menu_index == menu_cursor_pos ? 6 : 7) "m ")
					} else if(menu_items_type[menu_index] == "m" || menu_items_type[menu_index] == "c")
						printf("[" (is_checked(menu_index) ? "v" : " ") "] %s", wordwrap(filter_printable(menu_items[menu_index]), term_w - 6, 1, 1, 1))
					else if(menu_items_type[menu_index] == "r")
						printf("(" (is_checked(menu_index) ? "*" : " ") ") %s", wordwrap(filter_printable(menu_items[menu_index]), term_w - 6, 1, 1, 1))
					else if(menu_items_type[menu_index] == "h") {
						if(menu_items[menu_index] == "") {
							printf("\33[0;30;4" (menu_index == menu_cursor_pos ? 6 : 7) "m")
							for(j = 2; j < term_w; j++) printf("\342\224\200")
						} else {
							label = wordwrap(filter_printable(" " menu_items[menu_index]), term_w - 3, 0, 1, 1)
							label_length = mblength(label)
							printf("\33[1;37;40m%s ", label)
							if(term_w - label_length > 3) printf("\33[4" (menu_index == menu_cursor_pos ? 6 : 7) "m%" term_w - label_length - 3 "s", "")
						}
					} else if(menu_items_type[menu_index] == "b" || menu_items_type[menu_index] == "q") {
						if(menu_items[menu_index] == "") printf("%" term_w - 2 "s", "")
						else printf("%s", wordwrap(filter_printable(menu_items[menu_index]), term_w - 2, 1, 1, 1))
					} else {
						printf("\33[4" (menu_index == menu_cursor_pos ? 6 : 7) "m")
						if(menu_items[menu_index] == "") printf("%" term_w - 2 "s", "")
						else printf("%s", wordwrap(filter_printable(menu_items[menu_index]), term_w - 2, 1, 1, 1))
					}
				} else printf("%" term_w - 2 "s", "")
				if(scrollbar_height && i > scrollbar_offset && i <= scrollbar_offset + scrollbar_height)
					printf("\33[0;30;40m\342\226\210\n")
				else
					printf("\33[1;37;47m\342\224\202\n")
			}
			printf("\33[0;30;47m\342\224\224\33[1;37;47m")
			if(event == "search_edit" || ENVIRON["ui_search"] != "") {
				field_width = sprintf("%.0f", (term_w - 2) / 2) + 0
				if(field_width < 20) {
					if(term_w < 22) field_width = term_w - 2
					else field_width = 20
				}
				if(event == "search_edit") {
					gsub(/\n/, " ", ENVIRON["ui_value_l"])
					gsub(/\n/, " ", ENVIRON["ui_value_r"])
					ENVIRON["ui_value_l"] = filter_printable(ENVIRON["ui_value_l"])
					ENVIRON["ui_value_r"] = filter_printable(ENVIRON["ui_value_r"])
					field_cursor_pos = mblength(ENVIRON["ui_value_l"]) + 1
					value = ENVIRON["ui_value_l"] ENVIRON["ui_value_r"]
					value_length = field_cursor_pos + mblength(ENVIRON["ui_value_r"]) - 1
					field_offset = field_cursor_pos - sprintf("%.0f", field_width / 2)
					if(field_offset + field_width > value_length) {
						field_offset = value_length - field_width
						if(field_cursor_pos == value_length + 1) field_offset++
					}
					if(field_offset < 0) field_offset = 0
					print_at_end = print_at_end "\33[" term_h ";" field_cursor_pos - field_offset + 1 "H"
				} else {
					value = filter_printable(ENVIRON["ui_search"])
					gsub(/\n/, " ", value)
					value_length = mblength(value)
					field_cursor_pos = 0
					field_offset = 0
				}
				if(field_offset) value = substr(value, mbchrpos(value, field_offset + 1))
				if(field_offset + field_width < value_length) value = substr(value, 1, mbchrpos(value, field_width + 1) - 1)
				printf("\33[" (event == "search_edit" ? 1 : 0) ";37;44m%s", value)
				for(j = field_offset + field_width; j > value_length; j--) printf("_")
				printf("\33[1;37;47m")
			} else field_width = 0
			for(i = field_width + 2; i < term_w; i++) printf("\342\224\200")
			printf("\342\224\230\33[0m%s", print_at_end)
		}'
		putv ui_menu | LC_ALL=C awk -f /dev/fd/3 -- "$ui_stty_width" "$ui_stty_height" 3<<- EOF
		$awkprog
		EOF
		)
		putv ui_output | LC_ALL=C awk 'BEGIN { out = 0 } {
			if(out) {
				if(out == 2) print last_line
				else out = 2
				last_line = $0
			} else if($0 == "") out = 1
		} END { if(out == 2) printf("%s", last_line) }'
		ui_init=0
		eval "$(putv ui_output | awk '{ if($0 == "") exit; sub(/^./, ""); print $0 }')"
		term_input
	done
	ui_callback() { :; }
	[ "$ui_event" != exit ]
}

log() {
	if [ -t 1 ]; then
		printf '\33[1;37m%s:\33[0;32m %s\33[0m\n' "$program_name" "$*"
	else
		puts "$program_name: $*"
	fi
}
err() {
	if [ -t 2 ]; then
		if [ $# -gt 1 ]; then
			printf '\33[1;37m%s:\33[0;31m %s\33[0m\n' "$program_name" "$2" >&2
		else
			printf '\33[1;37m%s:\33[0;31m %s\33[0m\n' "$program_name" "$1" >&2
		fi
	else
		if [ $# -gt 1 ]; then
			puts "$program_name: $2" >&2
		else
			puts "$program_name: $1" >&2
		fi
	fi
	[ $# -gt 1 ] && exit "$1"
	return 1
}
err_usage() {
	[ $# -ne 0 ] && err "$@"
	set -- "$(usage | LC_ALL=C awk -- 'BEGIN { ARGC = 1; is_usage = 0 } {
		if(!is_usage) {
			sub(/^[\t\n\v\f\r ]+/, "")
			if(tolower(substr($0, 1, 6)) == "usage:") {
				$0 = substr($0, 7)
				is_usage = 1
			} else next
		}
		sub(/^[\t\n\v\f\r ]+/, ""); sub(/[\t\n\v\f\r ]+$/, "")
		if($0 == "") {
			if(is_usage == 2) exit
			else next
		}
		if(is_usage == 2) {
			if(tolower(substr($0, 1, 6)) == "usage:") {
				$0 = substr($0, 7)
				sub(/^[\t\n\v\f\r ]+/, "")
			}
			printf("%s", ARGV[1] ": ")
		}
		print "usage: " $0
		is_usage = 2
	} END { exit exit_code }' "$program_name")"
	[ -n "$1" ] && err "$1"
	err "try \`$program_name --help' for more information" >&2
	exit 1
}
checkutil() {
	unset -v checkutil__not_found_utils
	if [ ":$1" = :-s ]; then
		checkutil__silent=1
		shift
	else
		checkutil__silent=0
	fi
	[ ":$1" = :-- ] && shift
	set -- $*
	while [ $# -ne 0 ]; do
		{
			checkutil__util_path=$(command -v -- "$1") &&
			[ -n "$checkutil__util_path" ]
		} ||
			checkutil__not_found_utils=$checkutil__not_found_utils' '$1
		shift
	done
	[ -z "$checkutil__not_found_utils" ] || {
		checkutil__not_found_utils=${checkutil__not_found_utils# }
		[ $checkutil__silent -eq 0 ] && {
			case $lang in
			ru|ru_*)
				err "не удалось найти \`$(putv checkutil__not_found_utils | sed 's/ /'\'', `/g; s/\(.*\), /\1 и /')' в системе; PATH=$PATH"
				;;
			*)
				err "\`$(putv checkutil__not_found_utils | sed 's/ /'\'', `/g; s/\(.*\), /\1 and /')' is not found in the system; PATH=$PATH"
				;;
			esac
		}
		return 1
	}
}
check_gnu_coreutils() {
	unset -v check_gnu_coreutils__non_gnu_utils
	if [ ":$1" = :-s ]; then
		check_gnu_coreutils__silent=1
		shift
	else
		check_gnu_coreutils__silent=0
	fi
	[ ":$1" = :-- ] && shift
	set -- $*
	while [ $# -ne 0 ]; do
		"$1" --version 2>/dev/null | grep -qFi 'gnu coreutils' ||
			check_gnu_coreutils__non_gnu_utils=$check_gnu_coreutils__non_gnu_utils' '$1
		shift
	done
	[ -z "$check_gnu_coreutils__non_gnu_utils" ] || {
		check_gnu_coreutils__non_gnu_utils=${check_gnu_coreutils__non_gnu_utils# }
		[ $check_gnu_coreutils__silent -eq 0 ] && {
			case $lang in
			ru|ru_*)
				err "установленные в системе утилиты \`$(putv check_gnu_coreutils__non_gnu_utils | sed 's/ /'\'', `/g; s/\(.*\), /\1 и /')' не являются частью пакета GNU coreutils"
				;;
			*)
				err "utilities \`$(putv check_gnu_coreutils__non_gnu_utils | sed 's/ /'\'', `/g; s/\(.*\), /\1 and /')' installed in the system is not part of the GNU coreutils package"
				;;
			esac
		}
		return 1
	}
}
normalize_path() {
	[ -n "$2" ] && [ ":$2" != :- ] && {
		eval "$2=$(normalize_path "$1" -)"
		return
	}
	LC_ALL=C awk -- 'BEGIN {
		path = ARGV[2] "/"; if(ARGV[2] !~ /^\//) path = ARGV[1] "/" path
		gsub(/\0/, "", path); gsub(/\/\/+/, "/", path); gsub(/\/(\.\/)+/, "/", path)
		while(sub(/\/[^\/]+\/\.\.\//, "/", path)) { continue }
		sub(/\/\.\.\//, "/", path)
		if(path != "/") sub(/\/$/, "", path)
		if(ARGV[3] != "") {
			gsub(/\47/, "\47\134\47\47", path)
			print "\47" path "\47"
		} else print path
	}' "$PWD" "$1" "$2"
}
wait_user() {
	[ -z "$ui_mode__stty_old_settings" ] || return
	eawk 'BEGIN {
		if(ARGV[1] == "-c")
			print ml("Type \"yes\" to continue or \"q\" to exit", "ru:Введите \"yes\" для продолжения или \"q\", чтобы выйти")
		else
			print ml("Press Enter to continue or type \"q\" to exit", "ru:Нажмите Enter для продолжения или введите \"q\", чтобы выйти")
	}' "$1"
	{ ! gets wait_user__input || [ "$wait_user__input" = q ]; } && exit 0
	[ ":$1" != :-c ] || [ ":$wait_user__input" = :yes ]
}
mkvardir() {
	mkdir -pm 700 "/var/local/lib/$program_name" && {
		[ -z "$1" ] ||
		mkdir -p "/var/local/lib/$program_name/$1"
	}
}
get_lock() {
	[ -n "$1" ] || err 1 'get_lock: lock path is not specified'
	(
		trap '' $SIGNALS
		flock -n "$1/pid" sh -c 'pid=$(sed -n '\''/^[1-9][0-9]*$/!b; p; q'\'' "$0/pid"); [ -n "$pid" ] && ps -Ao pid | LC_ALL=C awk '\''BEGIN { ARGC = 1 } $1 == ARGV[1] { exit 1 }'\'' "$pid" && rm -rf "$0"' "$1" 2>/dev/null
		get_lock__i=10; while :; do
			if mkdir "$1" 2>/dev/null; then
				flock "$1/pid" sh -c '{ echo "$0" > "$1/pid" && [ ":$(cat "$1/pid")" = ":$0" ]; } || { echo 1; rm -rf "$1"; exit; }; echo 0' $$ "$1" 2>/dev/null |
				LC_ALL=C awk 'BEGIN { exit_code = 2 } /^[0-9]+$/ { exit_code = $0 } END { exit exit_code }'
				case $? in
				1) break;;
				2)
					{
						echo $$ > "$1/pid" &&
						[ ":$(cat "$1/pid")" = :$$ ]
					} || {
						rm -rf "$1"
						break
					}
					;;
				esac
				exit 0
			elif [ -d "$1" ]; then
				[ ":$2" = :1 ] && break
				get_lock__i=10
			else
				get_lock__i=$((get_lock__i - 1))
				[ $get_lock__i -le 0 ] && break
			fi
			sleep 1 2>/dev/null
		done
		exit 1
	) && return
	[ ":$3" = :1 ] && return 1
	err 1 "get_lock: unable to get lock \`$1'"
}
release_lock() {
	{ [ -n "$1" ] && [ -f "$1/pid" ]; } || return 0
	(
		trap '' $SIGNALS
		flock "$1/pid" sh -c '[ ":$(cat "$1/pid")" = ":$0" ] && rm -rf "$1"; echo 0' $$ "$1" 2>/dev/null |
		LC_ALL=C awk 'BEGIN { exit_code = 1 } $0 == "0" { exit_code = 0; exit } END { exit exit_code }' ||
		{ [ ":$(cat "$1/pid" 2>/dev/null)" = :$$ ] && rm -rf "$1"; }
	)
}
eawk() {
	eawk__awkprog='
	function err(message, err_exit_code,    OLD_ORS) {
		OLD_ORS = ORS; ORS = "\n"
		if(stderr_is_tty == -1) stderr_is_tty = !system("[ -t 2 ]")
		if(stderr_is_tty) message = "\33[1;37m" program_name ":\33[0;31m " message "\33[0m"
		else message = program_name ": " message
		print message | "cat 1>&2"
		ORS = OLD_ORS
		if(err_exit_code != 0 || err_exit_code != "") {
			exit_code = err_exit_code
			exit err_exit_code
		}
		return 1
	}
	function shell_escape(string, not_wrap_in_quotes) {
		gsub(/\0/, "", string)
		gsub(/\47/, "\47\134\47\47", string)
		if(not_wrap_in_quotes) return string
		return "\47" string "\47"
	}
	function ml(default_string, ml_strings,    ml_strings_arr, i, pos, splitted) {
		if(lang == "") return default_string
		split(ml_strings, splitted, "|")
		for(i in splitted) {
			pos = index(splitted[i], ":")
			if(pos > 1)
				ml_strings_arr[substr(splitted[i], 1, pos - 1)] = \
				substr(splitted[i], pos + 1)
		}
		if(lang in ml_strings_arr) return ml_strings_arr[lang]
		if(lang_group in ml_strings_arr) return ml_strings_arr[lang_group]
		return default_string
	}
	function tc(ctlseq) {
		if(!stdout_is_tty) return ""
		return "\33[" ctlseq "m"
	}
	function process_pkgs_list(string, array, ignore_or,    i, j, arr_and_add_el, arr_and, arr_and_len, arr_or, arr_or_len) {
		split("", array, ":")
		gsub(/(\([^)]+\)|\[[^]]+\]|[\t ]+)/, "", string)
		if(ignore_or) gsub(/\|/, ",", string)
		array[0] = 0
		arr_and_len = split(string, arr_and, ",")
		for(i = 1; i <= arr_and_len; i++) {
			arr_or_len = split(arr_and[i], arr_or, "|")
			arr_and_add_el = 1
			for(j = 1; j <= arr_or_len; j++) {
				if(!check_pkgname(arr_or[j], 1, 1)) { continue }
				if(arr_and_add_el) {
					array[0]++; array[array[0], 0] = 0
					arr_and_add_el = 0
				}
				array[array[0], ++array[array[0], 0]] = arr_or[j]
			}
		}
	}
	function split_pkg_name_arch(pkgname, result_arr, default_arch,    pos) {
		pos = index(pkgname, ":")
		if(pos) {
			result_arr["name"] = substr(pkgname, 1, pos - 1)
			result_arr["arch"] = substr(pkgname, pos + 1)
		} else {
			result_arr["name"] = pkgname
			result_arr["arch"] = default_arch
		}
	}
	function split_flip(str, arr, sep_regexp,    i, array_length) {
		split("", arr, ":")
		if(sep_regexp == 0 && sep_regexp == "")
			array_length = split(str, split_arr)
		else
			array_length = split(str, split_arr, sep_regexp)
		for(i = 1; i <= array_length; i++)
			arr[split_arr[i]] = i
		return array_length
	}
	function implode_keys(sep, arr,    i, res) {
		res = ""
		for(i in arr) {
			if(res == "") res = i
			else res = res sep i
		}
		return res
	}
	function match_any_of(string, regexp_array,    regexp) {
		for(regexp in regexp_array) {
			if(string ~ regexp) return 1
		}
		return 0
	}
	function conf_parse_line(    pos) {
		conf_key = conf_value = ""
		sub(/^[\t\v\f\r ]+/, "")
		if($0 == "" || substr($0, 1, 1)	== "#") return 0
		pos = index($0, "=")
		if(pos) {
			if(pos == 1) return 0
			conf_key = substr($0, 1, pos - 1)
			conf_value = substr($0, pos + 1)
		} else conf_key = $0
		if(index(conf_key, SUBSEP)) {
			conf_key = conf_value = ""
			return 0
		}
		return 1
	}
	function conf_add(array, key, value,    i, splitted, splitted_len, parent_key, cur_key) {
		if(value == 0 && value == "") {
			key = conf_key
			value = conf_value
		}
		if(index(key, SUBSEP)) return 0
		splitted_len = split(key, splitted, "/")
		for(i = 1; i <= splitted_len; i++) {
			cur_key = cur_key "/" splitted[i]
			if(!(cur_key in array)) {
				array[cur_key] = ""
				array[parent_key, ++array[parent_key, 0]] = splitted[i]
			}
			parent_key = cur_key
		}
		array["/" key] = value ""
		return 1
	}
	function conf_dump(array, key, chroot,    chroot_cut_len, i, len) {
		if(chroot && chroot_cut_len == "")
			chroot_cut_len = length(key) + 2
		if(key != "") {
			if(substr(key, 1, 1) != "/" || !(key in array)) return 0
			if(!array[key, 0] || array[key] != "")
				print substr(key, chroot ? chroot_cut_len : 2) (array[key] == "" ? "" : "=" array[key])
		}
		for(i = 1; i <= array[key, 0]; i++)
			conf_dump(array, key "/" array[key, i], chroot, chroot_cut_len)
		return 1
	}
	function check_pkgname(pkgname, with_arch, print_err_msg, err_msg_pre,    regexp) {
		regexp = "[a-zA-Z0-9.+-]+"
		if(with_arch) regexp = regexp "(:[a-zA-Z0-9.+-]+)?"
		if(pkgname ~ "^" regexp "$") return 1
		if(print_err_msg)
			err(err_msg_pre ml("invalid package name", "ru:некорректное имя пакета") ": `" pkgname "\47")
		return 0
	}
	function pkgdb_parse_line(line) {
		if(line == "") {
			if(pkgdb_state) {
				pkgdb_state = 0
				return 0
			}
			return 1
		}
		if(!pkgdb_state) {
			pkgdb_field = ""
			split("", f, ":")
		}
		pkgdb_state = 1
		if(match(line, /^[A-Za-z0-9_-]+:/)) {
			pkgdb_field = tolower(substr(line, 1, RLENGTH - 1))
			if(pkgdb_field in pkgdb_fields) {
				line = substr(line, RLENGTH + 1)
				sub(/^[\t ]+/, "", line)
				f[pkgdb_field] = line
			}
		} else if(pkgdb_field in pkgdb_fields && sub(/^[\t ]/, "", line)) {
			if(f[pkgdb_field] == "")
				f[pkgdb_field] = line
			else
				f[pkgdb_field] = f[pkgdb_field] "\n" line
		}
		return 1
	}
	BEGIN {
		argc = ARGC; ARGC = 1
		CONVFMT = "%.16g"
		exit_code = pkgdb_state = stdout_is_tty = 0
		stderr_is_tty = -1
		program_name = ENVIRON["EAWK_SCRIPT_NAME"]
		lang = lang_group = ENVIRON["EAWK_LANG"]
		sub(/_.*/, "", lang_group)
	}
	'"$1"
	shift
	LC_ALL=C EAWK_SCRIPT_NAME=$program_name EAWK_LANG=$lang awk -f /dev/fd/3 -- "$@" 3<<- EOF
	$eawk__awkprog
	EOF
}
unset -v log_ml__msg_prefix
log_ml() {
	[ -t 1 ]
	eawk 'BEGIN {
		stdout_is_tty = !ARGV[1]
		print tc("1;37") program_name ":" tc("0;32") " " ARGV[2] ml(ARGV[3], ARGV[4]) tc("0")
	}' "$?" "$log_ml__msg_prefix" "$1" "$2"
	unset -v log_ml__msg_prefix
}
unset -v err_ml__msg_prefix
err_ml() {
	[ -t 2 ]
	eawk 'BEGIN {
		stdout_is_tty = !ARGV[1]
		print tc("1;37") program_name ":" tc("0;31") " " ARGV[2] ml(ARGV[argc - 2], ARGV[argc - 1]) tc("0")
	}' "$?" "$err_ml__msg_prefix" "$@" >&2
	unset -v err_ml__msg_prefix
	[ $# -gt 2 ] && exit "$1"
	return 1
}
err_operation_failed() {
	err_ml 'operation completed with errors' 'ru:операция завершилась с ошибками'
	[ $# -ne 0 ] && exit "$1"
	return 1
}
get_dpkg_arch() {
	{ dpkg_arch=$(dpkg --print-architecture) && [ -n "$dpkg_arch" ]; } ||
		err_ml 'unable to get dpkg architecture' 'ru:невозможно получить архитектуру dpkg'
}
check_is_conf_dir() {
	[ -d "$confdir/common" ] || [ -d "$confdir/components" ] || {
		[ ":$1" != :-s ] && err "$(eawk 'BEGIN {
			print "`" ARGV[1] "\47 " ml("is not a configuration directory", "ru:не является каталогом конфигурации")
		}' "$confdir")"
	}
}
check_is_root() {
	[ "$(id -u)" = 0 ] || err_ml 'root privileges is required' 'ru:требуются привилегии root'
}
check_os_arch() {
	check_os_arch__errors=$(putv conf | eawk '{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		if("/prop/common/arch" in conf) {
			archs = ""
			for(i = 1; i <= conf["/prop/common/arch", 0]; i++) {
				arch = conf["/prop/common/arch", i]
				if(ARGV[1] == arch) exit
				if(archs != "") archs = archs ", "
				archs = archs arch
			}
			buffer_errors = ARGV[2] + 0
			if($0 != conf_value) {
				message = ml("OS architecture check failed: required", "ru:проверка архитектуры ОС не удалась: требуется") " \"" archs "\" " ml("instead of current", "ru:вместо текущей") " \"" ARGV[1] "\""
				if(buffer_errors) print message
				else err(message)
				exit 1
			}
		}
	}' "$dpkg_arch" "$1" 2>&1)
}
check_os_release() {
	check_os_release__errors=$(putv conf | eawk '{
		if(!conf_parse_line()) next
		if(conf_key == "prop/common/osrelease") {
			cmd = "unset -v ID VERSION_ID; for file in /etc/os-release /usr/lib/os-release; do [ -f \"$file\" ] && { . \"$file\"; break; }; done; printf \47%s\\n\47 \"$ID $VERSION_ID\""
			cmd | getline; close(cmd)
			if($0 != conf_value) {
				buffer_errors = ARGV[1] + 0
				message = ml("OS check failed: required", "ru:проверка ОС не удалась: требуется") " \"" conf_value "\" " ml("instead of current", "ru:вместо текущей") " \"" $0 "\""
				if(buffer_errors) print message
				else err(message)
				exit 1
			}
		}
	}' "$1" 2>&1)
}
get_env_path_extended() {
	eval "$(
		putv conf | eawk 'BEGIN {
			path = ARGV[1]
			dup[ARGV[1]] = ""
			splitted_len = split(ENVIRON["PATH"], splitted, ":")
			for(i = 1; i <= splitted_len; i++) {
				if(splitted[i] in dup) { continue }
				path = path ":" splitted[i]
				dup[splitted[i]] = ""
			}
			if(path != ENVIRON["PATH"])
				print "env_path_extended=" shell_escape(path)
		}' "$confdir" || puts 'return 1'
	)"
}
# Clears environment variables that can change the behavior of subcommands
# used in scripts
sanitize_scripts_env() {
	unset -v \
		SCRIPT_NAME \
		USERCONF
}
conf_load() {
	conf=$({
		cd "$confdir" || { puts 0; exit; }
		puts 1
		{ [ -n "$1" ] && [ ":$1" != :0 ]; } || ! [ -f "$confdir/config" ] || conf=$(cat "$confdir/config") || { puts 0; exit; }
		puts 1
		puts
		putv conf | sed -n '/^$/!p'
		puts
		[ -f common/control ] && puts common
		[ -d components ] && find -L components -path '*/*' -prune -type d | LC_ALL=C sort
	} | eawk 'BEGIN { state = 1 } {
		if(state == 1) {
			if($0 == "") { state++; next }
			if(!$0) {
				exit_code = 1
				exit
			}
		} else if(state == 2) {
			if($0 == "") { state++; next }
			if(!conf_parse_line()) next
			conf_add(conf, "conf/" conf_key, conf_value)
		} else if(state == 3) {
			component_key = "prop/" $0
			file_path = ARGV[1] "/" $0 "/control"
			conf_add(conf, component_key, "")
			if(!system("! [ -f " shell_escape(file_path) " ]")) next
			while((retval = getline < file_path) > 0) {
				if(!conf_parse_line()) { continue }
				conf_add(conf, component_key "/" conf_key, conf_value)
			}
			close(file_path)
			if(retval < 0)
				err(ml("unable to read file", "ru:невозможно прочитать файл") " `" file_path "\47", 1)
		}
	} END {
		if(exit_code) exit exit_code
		conf_dump(conf)
	}' "$confdir") || err_ml 'unable to load configuration' 'ru:невозможно загрузить конфигурацию'
}
unset -v conf_validate__affected_component
conf_validate() {
	unset -v conf_validate__errors
	conf=$(putv conf | eawk '
	function conf_err(key, message, is_hidden) {
		if(message == 0 && message == "") conf_errs[++conf_errs[0]] = key
		else conf_errs[++conf_errs[0]] = ml("invalid configuration value", "ru:некорректное значение конфигурации") " " (is_hidden ? "<" ml("value is hidden", "ru:значение скрыто") ">" : "\"" conf[key] "\"") " " ml("for key", "ru:для ключа") " \"" key "\""
		if(message != "")
			conf_errs[conf_errs[0]] = conf_errs[conf_errs[0]] ": " message
	}
	function print_conf_val(key, value) {
		if(value == 0 && value == "") value = conf[key]
		print substr(key, 2) (value == "" ? "" : "=" value)
	}
	function validate_key_exist(key) {
		if(!(key in conf)) {
			conf_err(ml("key", "ru:ключ") " \"" key "\" " ml("is not exist", "ru:не существует"))
			return 0
		}
		return 1
	}
	function validate_has_keys(key) {
		if(!validate_key_exist(key)) return 0
		if(!conf[key, 0]) {
			conf_err(ml("key", "ru:ключ") " \"" key "\" " ml("must contain child elements", "ru:должен содержать дочерние элементы"))
			return 0
		}
		return 1
	}
	function validate_boolean(key, default_value) {
		if(!validate_key_exist(key)) return 0
		if(conf[key] "" != "0" && conf[key] "" != "1") {
			conf_err(key, ml("the value must be 0 or 1", "ru:значение должно быть равно 0 или 1"))
			if(default_value == "") conf[key] = "0"
			else conf[key] = !!default_value ""
		}
		return 1
	}
	function validate_num(key, is_float, min_value, max_value, default_value, is_hidden,    value, value_new, suppress_err) {
		if(!validate_key_exist(key)) return 0
		value = conf[key] ""
		if(is_float) {
			if(value !~ /^-?(0|[1-9][0-9]*)(\.[0-9]*[1-9])?$/ || value == "-0") value_new = ""
			else value_new = value ""
		} else if(value == "") value_new = ""
		else value_new = int(value + 0) ""
		if(value_new != "") {
			if(value != value_new) {
				conf_err(key, "", is_hidden)
				suppress_err = 1
			}
			if(min_value != "" && value_new + 0 < min_value + 0) {
				value_new = default_value == "" ? min_value : default_value
				if(!suppress_err) conf_err(key, ml("value must be greater than or equal to", "ru:значение должно быть больше или равно") " " min_value, is_hidden)
			}
			if(max_value != "" && value_new + 0 > max_value + 0) {
				value_new = default_value == "" ? max_value : default_value
				if(!suppress_err) conf_err(key, ml("value must be less than or equal to", "ru:значение должно быть меньше или равно") " " max_value, is_hidden)
			}
		} else {
			conf_err(key, "", is_hidden)
			if(default_value != "") value_new = default_value ""
			else if(min_value != "") value_new = min_value ""
			else value_new = "0"
		}
		conf[key] = value_new ""
		return 1
	}
	function validate_regexp(key, regexp, default_value, is_hidden,    OLD_RSTART, OLD_RLENGTH) {
		if(!validate_key_exist(key)) return 0
		OLD_RSTART = RSTART; OLD_RLENGTH = RLENGTH
		match(conf[key], regexp)
		if(RSTART != 1 || RLENGTH != length(conf[key]))
			conf_err(key, ml("the value must match regular expression", "ru:значение должно соответствовать регулярному выражению") " \"" regexp "\"", is_hidden)
		if(RSTART)
			conf[key] = substr(conf[key], RSTART, RLENGTH)
		else if(default_value != 0 || default_value != "")
			conf[key] = default_value
		else
			conf[key] = ""
		RSTART = OLD_RSTART; RLENGTH = OLD_RLENGTH
		return 1
	}
	function validate_set(key, values, default_value,    i, values_string) {
		if(!validate_key_exist(key)) return 0
		if(!(conf[key] in values)) {
			for(i in values) {
				if(values_string != "") values_string = values_string ", "
				values_string = values_string "\"" i "\""
			}
			conf_err(key, ml("the value must be one of", "ru:значение должно являться одним из") " " values_string)
			if(default_value != 0 || default_value != "") conf[key] = default_value
			else conf[key] = ""
		}
		return 1
	}
	function process_conf_prop_spec(key, prop_name,    values, i) {
		if(key !~ /\57[a-z_][a-z0-9_]*$/) {
			conf_err(ml("invalid key name", "ru:некорректное имя ключа") " \"" key "\": " ml("the key name must match the regular expression", "ru:имя ключа должно соответствовать регулярному выражению") " \"^[a-z_][a-z0-9_]*$\"")
			return
		}
		if(key "/name[" lang "]" in conf)
			print_conf_val(key "/name", conf[key "/name[" lang "]"])
		else if(key "/name[" lang_group "]" in conf)
			print_conf_val(key "/name", conf[key "/name[" lang_group "]"])
		else if(key "/name" in conf)
			print_conf_val(key "/name")
		else
			print_conf_val(key "/name", prop_name)
		if(key "/description[" lang "]" in conf)
			print_conf_val(key "/description", conf[key "/description[" lang "]"])
		else if(key "/description[" lang_group "]" in conf)
			print_conf_val(key "/description", conf[key "/description[" lang_group "]"])
		else if(key "/description" in conf)
			print_conf_val(key "/description")
		split_flip("string integer float boolean select", values)
		if(!validate_set(key "/type", values, "string"))
			conf_add(conf, substr(key "/type", 2), "string")
		print_conf_val(key "/type")
		if(conf[key "/type"] == "string") {
			if(key "/default" in conf)
				print_conf_val(key "/default")
		} else if(conf[key "/type"] == "integer" || conf[key "/type"] == "float") {
			is_float = conf[key "/type"] == "float"
			if(key "/min" in conf) {
				validate_num(key "/min", is_float, "", "", 0)
				print_conf_val(key "/min")
			}
			if(key "/max" in conf) {
				validate_num(key "/max", is_float, (key "/min" in conf) ? conf[key "/min"] : "", "", 0)
				print_conf_val(key "/max")
			}
			if(key "/default" in conf) {
				validate_num(key "/default", is_float, (key "/min" in conf) ? conf[key "/min"] : "", (key "/max" in conf) ? conf[key "/max"] : "", 0)
				print_conf_val(key "/default")
			}
		} else if(conf[key "/type"] == "boolean") {
			if(key "/default" in conf) {
				validate_boolean(key "/default")
				print_conf_val(key "/default")
			}
		} else if(conf[key "/type"] == "select") {
			if(!validate_key_exist(key "/options") || !validate_has_keys(key "/options"))
				conf_add(conf, substr(key "/options/", 2), "")
			if(key "/default" in conf) {
				split("", values, ":")
				for(i = 1; i <= conf[key "/options", 0]; i++)
					values[conf[key "/options", i]] = ""
				validate_set(key "/default", values, conf[key "/options", 1])
				print_conf_val(key "/default")
			}
			for(i = 1; i <= conf[key "/options", 0]; i++) {
				option = key "/options/" conf[key "/options", i]
				if(option "/name[" lang "]" in conf)
					print_conf_val(option "/name", conf[option "/name[" lang "]"])
				else if(option "/name[" lang_group "]" in conf)
					print_conf_val(option "/name", conf[option "/name[" lang_group "]"])
				else if(option "/name" in conf)
					print_conf_val(option "/name")
				else
					print_conf_val(option "/name", conf[key "/options", i])
				if(option "/description[" lang "]" in conf)
					print_conf_val(option "/description", conf[option "/description[" lang "]"])
				else if(option "/description[" lang_group "]" in conf)
					print_conf_val(option "/description", conf[option "/description[" lang_group "]"])
				else if(option "/description" in conf)
					print_conf_val(option "/description")
			}
		}
		if(conf[key "/type"] != "boolean" && conf[key "/type"] != "select") {
			if(key "/hidden" in conf) {
				validate_boolean(key "/hidden")
				print_conf_val(key "/hidden")
			}
			if(key "/regexp" in conf) print_conf_val(key "/regexp")
		}
	}
	function process_conf_prop(key, key_spec, conf_arr_new,    i, is_hidden) {
		if(!(key in conf)) {
			if(key_spec "/default" in conf)
				conf[key] = conf[key_spec "/default"]
			else if(conf[key_spec "/type"] == "string")
				conf[key] = ""
			else if( \
				conf[key_spec "/type"] == "integer" || \
				conf[key_spec "/type"] == "float" || \
				conf[key_spec "/type"] == "boolean" \
			) conf[key] = 0
			else if(conf[key_spec "/type"] == "select")
				conf[key] = conf[key_spec "/options", 1]
		}
		is_hidden = key_spec "/hidden" in conf && conf[key_spec "/hidden"] + 0
		if(key_spec "/regexp" in conf)
			validate_regexp(key, conf[key_spec "/regexp"], (key_spec "/default" in conf) ? conf[key_spec "/default"] : "", is_hidden)
		if(conf[key_spec "/type"] == "integer" || conf[key_spec "/type"] == "float") {
			is_float = conf[key_spec "/type"] == "float"
			min_value = max_value = default_value = ""
			if(key_spec "/min" in conf) min_value = conf[key_spec "/min"]
			if(key_spec "/max" in conf) max_value = conf[key_spec "/max"]
			if(key_spec "/default" in conf) default_value = conf[key_spec "/default"]
			validate_num(key, is_float, min_value, max_value, default_value, is_hidden)
		} else if(conf[key_spec "/type"] == "boolean")
			validate_boolean(key)
		else if(conf[key_spec "/type"] == "select") {
			split("", options, ":")
			for(i = 1; i <= conf[key_spec "/options", 0]; i++)
				options[conf[key_spec "/options", i]] = ""
			validate_set(key, options, conf[key_spec "/options", 1])
		}
		conf_add(conf_new, substr(key, 2), conf[key])
	}
	BEGIN {
		dpkg_arch = ARGV[1]
		buffer_errors = ARGV[2] + 0
		process_key = ARGV[3]
		affected_component = ARGV[4]
	} {
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		if(process_key == "prop") {
			if("/prop/common/name[" lang "]" in conf)
				print_conf_val("/prop/common/name", conf["/prop/common/name[" lang "]"])
			else if("/prop/common/name[" lang_group "]" in conf)
				print_conf_val("/prop/common/name", conf["/prop/common/name[" lang_group "]"])
			else if("/prop/common/name" in conf)
				print_conf_val("/prop/common/name")
			if("/prop/common/description[" lang "]" in conf)
				print_conf_val("/prop/common/description", conf["/prop/common/description[" lang "]"])
			else if("/prop/common/description[" lang_group "]" in conf)
				print_conf_val("/prop/common/description", conf["/prop/common/description[" lang_group "]"])
			else if("/prop/common/description" in conf)
				print_conf_val("/prop/common/description")
			if("/prop/common/arch" in conf) {
				for(i1 = 1; i1 <= conf["/prop/common/arch", 0]; i1++)
					print_conf_val("/prop/common/arch/" conf["/prop/common/arch", i1], "")
			}
			if("/prop/common/osrelease" in conf)
				print_conf_val("/prop/common/osrelease")
			if("/prop/common/conf" in conf) {
				for(i1 = 1; i1 <= conf["/prop/common/conf", 0]; i1++)
					process_conf_prop_spec("/prop/common/conf/" conf["/prop/common/conf", i1], conf["/prop/common/conf", i1])
			}
			if("/prop/components" in conf) {
				components_lists_l = split("depends conflicts after", components_lists)
				for(i1 = 1; i1 <= conf["/prop/components", 0]; i1++) {
					component = "/prop/components/" conf["/prop/components", i1]
					if(component "/name[" lang "]" in conf)
						print_conf_val(component "/name", conf[component "/name[" lang "]"])
					else if(component "/name[" lang_group "]" in conf)
						print_conf_val(component "/name", conf[component "/name[" lang_group "]"])
					else if(component "/name" in conf)
						print_conf_val(component "/name")
					else
						print_conf_val(component "/name", conf["/prop/components", i1])
					if(component "/description[" lang "]" in conf)
						print_conf_val(component "/description", conf[component "/description[" lang "]"])
					else if(component "/description[" lang_group "]" in conf)
						print_conf_val(component "/description", conf[component "/description[" lang_group "]"])
					else if(component "/description" in conf)
						print_conf_val(component "/description")
					if(component "/arch" in conf) {
						for(i2 = 1; i2 <= conf[component "/arch", 0]; i2++)
							print_conf_val(component "/arch/" conf[component "/arch", i2], "")
					}
					for(i2 = 1; i2 <= components_lists_l; i2++) {
						if(!(component "/" components_lists[i2] in conf)) { continue }
						for(i3 = 1; i3 <= conf[component "/" components_lists[i2], 0]; i3++) {
							if(components_lists[i2] == "depends") {
								list_elem_splitted_l = split(conf[component "/" components_lists[i2], i3], list_elem_splitted, "|")
							} else {
								split("", list_elem_splitted, ":")
								list_elem_splitted_l = 1
								list_elem_splitted[1] = conf[component "/" components_lists[i2], i3]
							}
							is_valid = 1
							for(i4 = 1; i4 <= list_elem_splitted_l; i4++) {
								if(!("/prop/components/" list_elem_splitted[i4] in conf)) {
									is_valid = 0
									conf_err(ml("invalid key name", "ru:некорректное имя ключа") " \"" component "/" components_lists[i2] "/" conf[component "/" components_lists[i2], i3] "\": " ml("component", "ru:компонент") " \"" list_elem_splitted[i4] "\" " ml("does not exist", "ru:не существует"))
								}
							}
							if(is_valid)
								print_conf_val(component "/" components_lists[i2] "/" conf[component "/" components_lists[i2], i3], "")
						}
					}
					if(component "/conf" in conf) {
						for(i2 = 1; i2 <= conf[component "/conf", 0]; i2++)
							process_conf_prop_spec(component "/conf/" conf[component "/conf", i2], conf[component "/conf", i2])
					}
					components_indexes[conf["/prop/components", i1]] = i1
				}
				for(i1 = 1; i1 <= conf["/prop/components", 0]; i1++) {
					component = "/prop/components/" conf["/prop/components", i1]
					if(!(i1 in edge)) edge[i1] = ""
					if(!(component "/after" in conf)) { continue }
					for(i2 = 1; i2 <= conf[component "/after", 0]; i2++) {
						after_index = components_indexes[conf[component "/after", i2]]
						edge[after_index] = edge[after_index] " " i1
					}
				}
				do {
					last_sources = ""
					for(i1 in edge) last_sources = last_sources " " i1
					for(i1 in edge) {
						is_found = 0
						for(i2 in edge) {
							split(edge[i2], components, " ")
							for(i3 in components) {
								if(i1 == components[i3]) { is_found = 1; break }
							}
							if(is_found) { break }
						}
						if(!is_found) {
							print_conf_val("/prop/components-install-order/" conf["/prop/components", i1])
							split(edge[i1], components, " ")
							for(i2 in components) {
								if(!(components[i2] in edge)) edge[components[i2]] = ""
							}
							delete edge[i1]
						}
					}
					now_sources = ""
					for(i1 in edge) now_sources = now_sources " " i1
				} while(now_sources != last_sources)
				if(last_sources != "") conf_err(ml("unable to determine components installation order because there are cyclic dependencies", "ru:невозможно определить порядок установки компонентов, так как есть циклические зависимости"))
			}
			conf_dump(conf, "/conf")
		} else if(process_key == "conf") {
			conf_dump(conf, "/prop")
			if("/prop/common/conf" in conf) {
				for(i1 = 1; i1 <= conf["/prop/common/conf", 0]; i1++)
					process_conf_prop("/conf/common/" conf["/prop/common/conf", i1], "/prop/common/conf/" conf["/prop/common/conf", i1], conf_new)
			}
			if("/prop/components" in conf) {
				for(i1 = 1; i1 <= conf["/prop/components", 0]; i1++) {
					component_name = conf["/prop/components", i1]
					component = "/prop/components/" component_name
					if("/conf/components/" component_name in conf) {
						validate_boolean("/conf/components/" component_name)
						if(conf["/conf/components/" component_name] + 0)
							selected_components[component_name] = ""
					}
					conf_add(conf_new, "conf/components/" component_name, 0)
					if(!(component "/conf" in conf)) { continue }
					for(i2 = 1; i2 <= conf[component "/conf", 0]; i2++)
						process_conf_prop("/conf/components/" component_name "/" conf[component "/conf", i2], component "/conf/" conf[component "/conf", i2], conf_new)
				}
			}
			split("", dup, ":")
			for(i1 in selected_components) {
				split("", deps, ":")
				split("", new_deps, ":")
				new_deps[i1] = ""
				do {
					has_new_deps = 0
					split("", set_deps, ":")
					for(i2 in new_deps) {
						component = "/prop/components/" i2
						if(!(component "/depends" in conf)) { continue }
						for(i3 = 1; i3 <= conf[component "/depends", 0]; i3++) {
							depends_on_arr_l = split(conf[component "/depends", i3], depends_on_arr, "|")
							depends_on = ""
							for(i4 = 1; i4 <= depends_on_arr_l; i4++) {
								dep = depends_on_arr[i4]
								if(dep in deps || dep in new_deps || dep in set_deps) {
									depends_on_arr_l = 0
									break
								}
								if(depends_on == "" && dep in selected_components)
									depends_on = dep
							}
							if(!depends_on_arr_l) { continue }
							if(depends_on == "") depends_on = depends_on_arr[1]
							has_new_deps = 1
							set_deps[depends_on] = ""
							if(!(depends_on in selected_components || (i2 SUBSEP depends_on) in dup)) {
								conf_err(ml("component", "ru:компонент") " \"" i2 "\" (\"" conf[component "/name"] "\") " ml("depends on", "ru:зависит от") " \"" depends_on "\" (\"" conf["/prop/components/" depends_on "/name"] "\")")
								dup[i2, depends_on] = ""
							}
						}
					}
					for(i2 in new_deps) deps[i2] = ""
					split("", new_deps, ":")
					if(has_new_deps)
						for(i2 in set_deps) new_deps[i2] = ""
				} while(has_new_deps)
				for(i2 in deps) components_deps[i1, ++components_deps[i1, 0]] = i2
			}
			split("", dup, ":")
			split("", incompat_arch_components, ":")
			iteration_order[0] = 0
			for(i1 in selected_components) {
				if(i1 == affected_component) { continue }
				iteration_order[++iteration_order[0]] = i1
			}
			if(affected_component in selected_components)
				iteration_order[++iteration_order[0]] = affected_component
			for(i1 = 1; i1 <= iteration_order[0]; i1++) {
				i1_val = iteration_order[i1]
				if(i1_val in unselected_components) { continue }
				unselect_component = 0
				for(i2 = 1; i2 <= components_deps[i1_val, 0]; i2++) {
					dep = components_deps[i1_val, i2]
					if("/prop/components/" dep "/arch" in conf) {
						if(dep in incompat_arch_components) {
							unselect_component = 1
							break
						}
						is_arch_compat = 0
						archs = ""
						for(i3 = 1; i3 <= conf["/prop/components/" dep "/arch", 0]; i3++) {
							arch = conf["/prop/components/" dep "/arch", i3]
							if(arch == dpkg_arch) {
								is_arch_compat = 1
								break
							}
							if(archs != "") archs = archs ", "
							archs = archs arch
						}
						if(!is_arch_compat) {
							conf_err(ml("component", "ru:компонент") " \"" dep "\" (\"" conf["/prop/components/" dep "/name"] "\") " ml("cannot be installed on the current architecture", "ru:не может быть установлен на текущую архитектуру") " \"" dpkg_arch "\", " ml("required", "ru:требуется") " \"" archs "\"")
							incompat_arch_components[dep] = ""
							unselect_component = 1
							break
						}
					}
					if(!("/prop/components/" dep "/conflicts" in conf)) { continue }
					for(i3 = 1; i3 <= conf["/prop/components/" dep "/conflicts", 0]; i3++) {
						conflict = conf["/prop/components/" dep "/conflicts", i3]
						is_conflict = 0
						for(i4 in selected_components) {
							if(i4 in unselected_components) { continue }
							for(i5 = 1; i5 <= components_deps[i4, 0]; i5++) {
								if(components_deps[i4, i5] == conflict) {
									is_conflict = 1
									break
								}
							}
							if(is_conflict) { break }
						}
						if(!is_conflict) { continue }
						unselect_component = 1
						if(!((dep "/" conflict) in dup)) {
							conf_err(ml("component", "ru:компонент") " \"" dep "\" (\"" conf["/prop/components/" dep "/name"] "\") " ml("conflicts with", "ru:конфликтует с") " \"" conflict "\" (\"" conf["/prop/components/" conflict "/name"] "\")")
							dup[dep "/" conflict] = ""
						}
					}
				}
				if(unselect_component) unselected_components[i1_val] = ""
				else for(i2 = 1; i2 <= components_deps[i1_val, 0]; i2++)
					conf_new["/conf/components/" components_deps[i1_val, i2]] = 1
			}
			conf_dump(conf_new)
		}
		if(conf_errs[0]) {
			if(buffer_errors) print ""
			for(i = 1; i <= conf_errs[0]; i++) {
				if(buffer_errors) print conf_errs[i]
				else err(conf_errs[i])
			}
			if(buffer_errors) exit 10
			exit 1
		}
	}' "$dpkg_arch" "$1" "$2" "$conf_validate__affected_component") || {
		[ $? -eq 10 ] && {
			conf_validate__errors=$(putv conf | LC_ALL=C awk 'BEGIN { do_out = 0 } {
				if(do_out) print $0
				else if($0 == "") do_out = 1
			}')
			conf=$(putv conf | LC_ALL=C awk '{ if($0 == "") exit; print $0 }')
		}
		unset -v conf_validate__affected_component
		return 1
	}
	unset -v conf_validate__affected_component
}
get_sel_components_dirs() {
	putv conf | eawk '
	function process_conf_key(path, idx,    component) {
		component = conf[path, idx]
		if(!(conf["/conf/components/" component] + 0)) return
		print "components/" component
	}
	{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		if(ARGV[1] + 0) path = "/prop/components"
		else path = "/prop/components-install-order"
		reverse_order = ARGV[2] + 0
		if(reverse_order) {
			for(i = conf[path, 0]; i > 0; i--)
				process_conf_key(path, i)
		} else {
			for(i = 1; i <= conf[path, 0]; i++)
				process_conf_key(path, i)
		}
	}' "$1" "$2"
}
pkgs_list_load() {
	pkgs_list_install=$({
		! [ -e "$confdir/common/unmanaged-packages" ]
		load_unmanaged_pkgs=$?
		cd "$confdir" || { puts 0; exit; }
		puts 1
		[ $load_unmanaged_pkgs -ne 0 ] && {
			sed -n '/^$/!p' "$confdir/common/unmanaged-packages" || { puts; puts 0; exit; }
		}
		puts
		puts 1
		{ [ -z "$4" ] || [ ":$4" = :0 ]; } && { [ $load_unmanaged_pkgs -ne 0 ] || [ $overlapping_install -ne 0 ]; } && {
			{
				buf=$(dpkg --get-selections) &&
				putv buf | sed -n '/^$/!p'
			} || { puts; puts 0; exit; }
			unset -v buf
		}
		puts
		puts 1
		{
			puts common
			if [ ":$1" = :all ]; then
				[ -d components ] && find -L components -path '*/*' -prune -type d | LC_ALL=C sort
			else
				get_sel_components_dirs 1
			fi
		} | while gets dir; do
			[ -d "$dir/pkglists" ] && find -L "$dir/pkglists" -type f
		done
		puts
		[ -n "$2" ] && putv "$2"
	} | eawk '
		function check_pkglist_pkgname(file_path, line, pkgname) {
			if(check_pkgname(pkgname, 1, 1, file_path ":" line ": ")) return 1
			file_has_errors = exit_code = 1
			return 0
		}
		function common_err(message) {
			err(message)
			file_has_errors = exit_code = 1
		}
		function conf_err(file_path, line, message) {
			err(file_path ":" line ": " message)
			file_has_errors = exit_code = 1
		}
		function cmd_err(cmd) {
			err(ml("command", "ru:команда") " `" cmd "\47 " ml("failed", "ru:завершилась с ошибкой"), 1)
		}
		function normalize_pkg_name(pkg_name,    pkg_name_len) {
			pkg_name_len = length(pkg_name)
			if( \
				dpkg_arch_len && pkg_name_len > dpkg_arch_len && \
				substr(pkg_name, pkg_name_len - dpkg_arch_len) == ":" dpkg_arch \
			)
				pkg_name = substr(pkg_name, 1, pkg_name_len - dpkg_arch_len - 1)
			return pkg_name
		}
		function check_pkg_exist(pkg, file_path, line,    message) {
			if(normalize_pkg_name(pkg) in pkgs_all) return 1
			message = ml("package", "ru:пакет") " `" pkg "\47 " ml("does not exist", "ru:не существует")
			if(line != 0 || line != "") conf_err(file_path, line, message)
			else err(message)
			return 0
		}
		function update_pkgs_index(    cmd) {
			if(pkgs_index_updated) return
			cmd = "apt-get update"
			if(system(cmd " >&2")) cmd_err(cmd)
			pkgs_index_updated = 1
		}
		function parse_pkgdb_from_cmd(cmd, ignore_dups,    cmd_full, last) {
			cmd_full = cmd "; echo $?"
			if((cmd_full | getline) > 0) {
				last = $0
				while((cmd_full | getline) > 0) {
					if(!pkgdb_parse_line(last)) process_pkgdb_fields(ignore_dups)
					last = $0
				}
			}
			close(cmd_full)
			if(last + 0) cmd_err(cmd)
			if(pkgdb_state) process_pkgdb_fields(ignore_dups)
			pkgdb_state = 0
		}
		function add_dep_raw(pkg_parent, pkg_child, is_hard) {
			pkgs_deps_raw[pkg_parent]++
			pkgs_deps_raw[pkg_parent, pkgs_deps_raw[pkg_parent], 1] = pkg_child
			if(is_hard)
				pkgs_deps_raw[pkg_parent, pkgs_deps_raw[pkg_parent], 2] = is_hard
		}
		function add_dep(pkg_parent, pkg_child, is_hard,    is_dep_exist) {
			if(pkg_parent == pkg_child) return
			is_dep_exist = pkg_parent SUBSEP pkg_child in pkgs_deps_all
			if(!is_dep_exist || !is_hard)
				pkgs_deps_all[pkg_parent, pkg_child] = is_hard
			if(is_dep_exist) return
			pkgs_deps[pkg_parent, ++pkgs_deps[pkg_parent]] = pkg_child
			pkgs_for[pkg_child, ++pkgs_for[pkg_child]] = pkg_parent
		}
		function process_pkgdb_fields(ignore_dups, is_pkg_local,    pkg, i, j, splitted, not_soft_deps, pos) {
			if(check_pkgname(f["package"], 0, 1)) {
				pkg = f["package"]
				if(f["architecture"] != "all" && f["architecture"] != dpkg_arch)
					pkg = pkg ":" f["architecture"]
				if(is_pkg_local) {
					if(!(pkg in pkgs_all)) pkgs_local[pkg] = ""
				} else if(pkg in pkgs_local) delete pkgs_local[pkg]
				if(ignore_dups && pkg in pkgs_all) return
				if(f["multi-arch"] == "" || f["multi-arch"] == "same")
					pkgs_all[pkg] = 0
				else if(f["multi-arch"] == "allowed")
					pkgs_all[pkg] = 1
				else if(f["multi-arch"] == "foreign")
					pkgs_all[pkg] = 2
				process_pkgs_list(f["provides"], splitted, 1)
				for(i = 1; i <= splitted[0]; i++) {
					sub(/:[^:]+$/, "", splitted[i, 1])
					if(splitted[i, 1] == f["package"]) { continue }
					pkgs_virtual[splitted[i, 1]]
					pkgs_virtual_deps[splitted[i, 1], ++pkgs_virtual_deps[splitted[i, 1]]] = pkg
				}
				process_pkgs_list(f["depends"] "," f["pre-depends"], splitted)
				for(i = 1; i <= splitted[0]; i++) {
					if(splitted[i, 0] > 1) {
						for(j = 1; j <= splitted[i, 0]; j++) {
							add_dep_raw(pkg, splitted[i, j], 0)
							not_soft_deps[splitted[i, j]] = ""
						}
					} else {
						add_dep_raw(pkg, splitted[i, 1], 1)
						not_soft_deps[splitted[i, 1]] = ""
					}
				}
				process_pkgs_list(f["recommends"] "," f["suggests"], splitted, 1)
				for(i = 1; i <= splitted[0]; i++) {
					if(!(splitted[i, 1] in not_soft_deps))
						add_dep_raw(pkg, splitted[i, 1], 0)
				}
			}
		}
		function analyze_pkg_deps_chains(pkg,    manual_pkg, local_pkgs_excluded, i, j, iteration_order, pkg_parent, pkg_child, pkg_virtual, pkg_virtual_dbname, is_hard, suitable_dep, check_archs) {
			if(manual_pkg == 0 && manual_pkg == "") manual_pkg = pkg
			else {
				if(pkg in local_pkgs_excluded) return
				if(manual_pkg != "" && pkg in list_pkgs_all)
					list_pkgs_for_manual[pkg, ++list_pkgs_for_manual[pkg, 0]] = manual_pkg
			}
			local_pkgs_excluded[pkg] = ""
			if(!(pkg in list_pkgs_included && list_pkgs_included[pkg] == fn)) {
				split_pkg_name_arch(pkg, pkg_parent, dpkg_arch)
				for(i = 1; i <= pkgs_deps_raw[pkg]; i++) {
					split_pkg_name_arch(pkgs_deps_raw[pkg, i, 1], pkg_child)
					if(pkg_child["arch"] == "all") pkg_child["arch"] = dpkg_arch
					is_hard = pkg SUBSEP i SUBSEP 2 in pkgs_deps_raw && pkgs_deps_raw[pkg, i, 2]
					if(pkg_child["name"] in pkgs_virtual) {
						iteration_order[0] = 0
						for(j = 1; j <= pkgs_virtual_deps[pkg_child["name"]]; j++) {
							pkg_virtual_dbname = pkgs_virtual_deps[pkg_child["name"], j]
							if(pkg_virtual_dbname in list_pkgs_all)
								iteration_order[++iteration_order[0]] = pkg_virtual_dbname
						}
						for(j = 1; j <= pkgs_virtual_deps[pkg_child["name"]]; j++) {
							pkg_virtual_dbname = pkgs_virtual_deps[pkg_child["name"], j]
							if(!(pkg_virtual_dbname in list_pkgs_all) && pkg_virtual_dbname in lists_pkgs_all)
								iteration_order[++iteration_order[0]] = pkg_virtual_dbname
						}
						for(j = 1; j <= iteration_order[0]; j++) {
							pkg_virtual_dbname = iteration_order[j]
							if(pkg_child["arch"] == "any") {
								if(!(pkg_virtual_dbname in pkgs_all && pkgs_all[pkg_virtual_dbname] == 1)) { continue }
							} else if(!(pkg_virtual_dbname in pkgs_all && pkgs_all[pkg_virtual_dbname] == 2)) {
								split_pkg_name_arch(pkg_virtual_dbname, pkg_virtual, dpkg_arch)
								if(pkg_virtual["arch"] != (pkg_child["arch"] == "" ? pkg_parent["arch"] : pkg_child["arch"])) { continue }
							}
							is_hard = 0
							add_dep(pkg, pkg_virtual_dbname, 0)
						}
					}
					if(pkg_child["arch"] == "" || pkg_child["arch"] == "any" || pkg_child["arch"] == dpkg_arch)
						suitable_dep = pkg_child["name"]
					else
						suitable_dep = pkg_child["name"] ":" pkg_child["arch"]
					if( \
						( \
							!(is_hard ? suitable_dep in pkgs_all : suitable_dep in list_pkgs_all) || \
							(pkg_child["arch"] == "" && pkg_parent["arch"] != dpkg_arch && !(suitable_dep in pkgs_all && pkgs_all[suitable_dep] == 2)) || \
							(pkg_child["arch"] == "any" && !(suitable_dep in pkgs_all && pkgs_all[suitable_dep] == 1)) \
						) && \
						(pkg_child["arch"] == "" || pkg_child["arch"] == "any") \
					) {
						if(!is_hard) suitable_dep = ""
						split("", check_archs, ":")
						if(pkg_parent["arch"] != dpkg_arch)
							check_archs[++check_archs[0]] = pkg_parent["arch"]
						for(j in foreign_archs) {
							if(j != pkg_parent["arch"])
								check_archs[++check_archs[0]] = j
						}
						for(j = 1; j <= check_archs[0]; j++) {
							if(!(is_hard ? pkg_child["name"] ":" check_archs[j] in pkgs_all : pkg_child["name"] ":" check_archs[j] in list_pkgs_all)) { continue }
							if(pkg_child["arch"] == "any") {
								if(!(pkg_child["name"] ":" check_archs[j] in pkgs_all && pkgs_all[pkg_child["name"] ":" check_archs[j]] == 1)) { continue }
							} else if(pkg_parent["arch"] != check_archs[j] && !(pkg_child["name"] ":" check_archs[j] in pkgs_all && pkgs_all[pkg_child["name"] ":" check_archs[j]] == 2)) { continue }
							suitable_dep = pkg_child["name"] ":" check_archs[j]
							break
						}
					}
					if(suitable_dep == "") { continue }
					add_dep(pkg, suitable_dep, is_hard)
				}
			}
			list_pkgs_included[pkg] = fn
			for(i = 1; i <= pkgs_deps[pkg]; i++) {
				if(pkgs_deps_all[pkg, pkgs_deps[pkg, i]]) {
					if(!(pkgs_deps[pkg, i] in pkgs_all))
						common_err(ml("package", "ru:пакет") " `" pkgs_deps[pkg, i] "\47 " ml("does not exist, but is required for package", "ru:не существует, однако требуется для пакета") " `" pkg "\47")
				} else if(!(pkgs_deps[pkg, i] in list_pkgs_all)) { continue }
				analyze_pkg_deps_chains(pkgs_deps[pkg, i], manual_pkg, local_pkgs_excluded)
			}
		}
		function compare_lists(arr_comp_cur, arr_comp_expected, list_name,    i) {
			for(i in arr_comp_cur) {
				if(i in arr_comp_expected) { continue }
				conf_err(file_path, ln, ml("unnecessary element", "ru:лишний элемент") " `" i "\47 " ml("inside a " list_name "() list of package", "ru:внутри списка " list_name "() пакета") " `" pkg "\47")
			}
			for(i in arr_comp_expected) {
				if(i in arr_comp_cur) { continue }
				conf_err(file_path, ln, ml("missing element", "ru:недостающий элемент") " `" i "\47 " ml("inside a " list_name "() list of package", "ru:внутри списка " list_name "() пакета") " `" pkg "\47")
			}
		}
		BEGIN {
			state = 1
			has_pkgs = has_foreign_archs =\
			pkgs_index_updated = parse_local_pkgs_info = 0
			dpkg_arch = ARGV[2]
			dpkg_arch_len = length(dpkg_arch)
			overlapping_install = ARGV[3] + 0
			verify_only = ARGV[5] + 0
			autofix_errors = ARGV[6] + 0
			pkgdb_fields["package"] = pkgdb_fields["architecture"] =\
			pkgdb_fields["multi-arch"] = pkgdb_fields["provides"] =\
			pkgdb_fields["depends"] = pkgdb_fields["pre-depends"] =\
			pkgdb_fields["recommends"] = pkgdb_fields["suggests"] = ""
		} {
			if(state == 1) {
				if(!$0) { exit_code = 1; exit }
				state++; next
			} else if(state == 2) {
				if($0 == "") { state++; next }
				unmanaged_pkgs_regexps[$0] = ""
			} else if(state == 3) {
				if(!$0) { exit_code = 1; exit }
				state++
			} else if(state == 4) {
				if($0 == "") { state++; next }
				pkg = $1
				split_pkg_name_arch(pkg, splitted)
				if(splitted["arch"] == dpkg_arch) pkg = splitted["name"]
				if(overlapping_install)
					list_pkgs_included[pkg] = 0
				else if(match_any_of(splitted["name"], unmanaged_pkgs_regexps))
					unmanaged_pkgs[pkg] = ""
			} else if(state == 5) {
				if(!$0) { exit_code = 1; exit }
				state++
			} else if(state == 6) {
				if($0 == "") {
					if(ARGV[4] != "") parse_local_pkgs_info = 1
					exit
				}
				if($0 ~ /\.(old|bak)$/) next
				file_path = ARGV[1] "/" $0
				if(!system("! [ -f " shell_escape(file_path) " ]")) next
				pkgs_lists[0]++
				pkgs_lists[pkgs_lists[0], 1] = file_path
				split("", pkgs_dup, ":")
				file_has_errors = ln = n = 0
				while((retval = getline < file_path) > 0) {
					ln++
					sub(/^[\t\v\f\r ]+/, "")
					if($0 == "" || substr($0, 1, 1)	== "#") { continue }
					gsub(/[\t\v\f\r ]*\(/, "( "); gsub(/\)/, " )")
					if(!check_pkglist_pkgname(file_path, ln, $1)) { continue }
					if($1 in pkgs_dup) {
						conf_err(file_path, ln, ml("duplicate value of field 1", "ru:дублирующееся значение поля 1") ": `" $1 "\47")
						continue
					}
					pkgs_dup[$1] = ""
					if($2 != "auto" && $2 != "manual") {
						conf_err(file_path, ln, ml("invalid value", "ru:некорректное значение") " `" $2 "\47 " ml("of field", "ru:поля") " 2: " ml("must be `auto\47 or `manual\47", "ru:должно быть равно `auto\47 или `manual\47"))
						continue
					}
					split("", line_pkgs_for, ":")
					split("", line_pkgs_for_manual, ":")
					for(i = 3; i <= NF; i++) {
						if($i == "for(" || $i == "for_manual(") {
							list_name = substr($i, 1, length($i) - 1)
							split("", list_pkgs_dup, ":")
							while(i < NF) {
								i++
								if($i == ")") { break }
								if(!check_pkglist_pkgname(file_path, ln, $i)) { continue }
								if($i in list_pkgs_dup) {
									conf_err(file_path, ln, ml("duplicate element", "ru:дублирующийся элемент") " `" $i "\47 " ml("inside a " list_name "() list", "ru:внутри списка " list_name "()"))
									continue
								}
								list_pkgs_dup[$i] = ""
								if(list_name == "for")
									line_pkgs_for[++line_pkgs_for[0]] = $i
								else if(list_name == "for_manual")
									line_pkgs_for_manual[++line_pkgs_for_manual[0]] = $i
							}
							if($i != ")") { i = 0; break }
						} else
							conf_err(file_path, ln, ml("unexpected token", "ru:неожиданный маркер") " `" $i "\47")
						if(!i) break
					}
					split("", list_pkgs_dup, ":")
					if(!i) {
						conf_err(file_path, ln, ml("missing closing parenthesis", "ru:отсутствует закрывающая скобка"))
						continue
					}
					has_pkgs = 1
					n++
					pkg = normalize_pkg_name($1)
					lists_pkgs_all[pkg] = ""
					if(match(pkg, /:[^:]+$/)) {
						has_foreign_archs = 1
						foreign_archs[substr(pkg, RSTART + 1)] = ""
					}
					pkgs_lists[pkgs_lists[0], 3, n, 1] = ln
					pkgs_lists[pkgs_lists[0], 3, n, 2] = $1
					pkgs_lists[pkgs_lists[0], 3, n, 3] = $2 == "manual"
					pkgs_lists[pkgs_lists[0], 3, n, 4, 0] = line_pkgs_for_manual[0]
					for(i = 1; i <= line_pkgs_for_manual[0]; i++)
						pkgs_lists[pkgs_lists[0], 3, n, 4, i] = line_pkgs_for_manual[i]
					pkgs_lists[pkgs_lists[0], 3, n, 5, 0] = line_pkgs_for[0]
					for(i = 1; i <= line_pkgs_for[0]; i++)
						pkgs_lists[pkgs_lists[0], 3, n, 5, i] = line_pkgs_for[i]
				}
				close(file_path)
				if(retval < 0)
					err(ml("unable to read file", "ru:невозможно прочитать файл") " `" file_path "\47", 1)
				pkgs_lists[pkgs_lists[0], 2] = file_has_errors
				pkgs_lists[pkgs_lists[0], 3, 0] = n
			}
		} END {
			if(exit_code) exit exit_code
			if(!has_pkgs) exit 0
			split("", line_pkgs_for, ":")
			split("", line_pkgs_for_manual, ":")
			split("", pkgs_dup, ":")
			if(!verify_only && has_foreign_archs) {
				cmd_main_part = "dpkg --print-foreign-architectures"
				cmd = cmd_main_part "; echo $?"
				last = ""
				while((cmd | getline) > 0) {
					if(last != "") cur_foreign_archs[last] = ""
					last = $1
				}
				close(cmd)
				if(last + 0) cmd_err(cmd_main_part)
				has_new_foreign_archs = 0
				for(i in foreign_archs) {
					if(i in cur_foreign_archs) continue
					has_new_foreign_archs = 1
					new_foreign_archs[i] = ""
				}
				if(has_new_foreign_archs) {
					for(i in new_foreign_archs) {
						cmd = "dpkg --add-architecture " shell_escape(i)
						if(system(cmd " > /dev/null")) cmd_err(cmd)
					}
					update_pkgs_index()
				}
			}
			if(!verify_only) update_pkgs_index()
			parse_pkgdb_from_cmd("apt-cache dumpavail")
			if(parse_local_pkgs_info) {
				while(getline > 0) {
					if(!pkgdb_parse_line($0)) process_pkgdb_fields(1, 1)
				}
				if(pkgdb_state) process_pkgdb_fields(1, 1)
				pkgdb_state = 0
			}
			parse_pkgdb_from_cmd("cat /var/lib/dpkg/status", 1)
			if(!verify_only) {
				fn = 0
				split("", pkgs_deps, ":")
				split("", pkgs_deps_all, ":")
				split("", pkgs_for, ":")
				split("", list_pkgs_all, ":")
				for(pkg in unmanaged_pkgs) {
					if(pkg in pkgs_all) list_pkgs_all[pkg]
				}
				for(pkg in list_pkgs_all) analyze_pkg_deps_chains(pkg)
			}
			for(fn = 1; fn <= pkgs_lists[0]; fn++) {
				file_path = pkgs_lists[fn, 1]
				file_has_errors = pkgs_lists[fn, 2]
				if(autofix_errors) ffc = ""
				split("", pkgs_deps, ":")
				split("", pkgs_deps_all, ":")
				split("", pkgs_for, ":")
				split("", list_pkgs_all, ":")
				split("", list_pkgs_manual, ":")
				split("", list_pkgs_for_manual, ":")
				for(i1 = 1; i1 <= pkgs_lists[fn, 3, 0]; i1++) {
					pkg = normalize_pkg_name(pkgs_lists[fn, 3, i1, 2])
					if(!(pkg in pkgs_all)) { continue }
					list_pkgs_all[pkg] = ""
					if(pkgs_lists[fn, 3, i1, 3])
						list_pkgs_manual[pkg] = ""
				}
				for(pkg in list_pkgs_manual)
					analyze_pkg_deps_chains(pkg)
				for(i1 = 1; i1 <= pkgs_lists[fn, 3, 0]; i1++) {
					ln = pkgs_lists[fn, 3, i1, 1]
					pkg_raw = pkgs_lists[fn, 3, i1, 2]
					if(!check_pkg_exist(pkg_raw, file_path, ln)) { continue }
					pkg = normalize_pkg_name(pkg_raw)
					if(!(pkg in list_pkgs_included && list_pkgs_included[pkg] == fn)) {
						conf_err(file_path, ln, ml("package", "ru:пакет") " `" pkg_raw "\47 " ml("is not found in dependency chains of packages marked as manual", "ru:не найден в цепочках зависимостей пакетов, помеченных как manual"))
						continue
					}
					split("", comp_pkgs, ":")
					split("", line_pkgs_for_manual, ":")
					for(i2 = 1; i2 <= pkgs_lists[fn, 3, i1, 4, 0]; i2++)
						comp_pkgs[normalize_pkg_name(pkgs_lists[fn, 3, i1, 4, i2])] = ""
					for(i2 = 1; i2 <= list_pkgs_for_manual[pkg, 0]; i2++)
						line_pkgs_for_manual[list_pkgs_for_manual[pkg, i2]] = ""
					compare_lists(comp_pkgs, line_pkgs_for_manual, "for_manual")
					split("", comp_pkgs, ":")
					for(i2 = 1; i2 <= pkgs_lists[fn, 3, i1, 5, 0]; i2++)
						comp_pkgs[normalize_pkg_name(pkgs_lists[fn, 3, i1, 5, i2])] = ""
					split("", line_pkgs_for, ":")
					has_pkgs_for = 0
					for(i2 = 1; i2 <= pkgs_for[pkg]; i2++) {
						split_pkg_name_arch(pkgs_for[pkg, i2], splitted)
						if(!(pkgs_for[pkg, i2] in comp_pkgs || !match_any_of(splitted["name"], unmanaged_pkgs_regexps)) || !(pkgs_for[pkg, i2] in list_pkgs_included && list_pkgs_included[pkgs_for[pkg, i2]] == fn) || pkgs_deps_all[pkgs_for[pkg, i2], pkg]) { continue }
						has_pkgs_for = 1
						line_pkgs_for[pkgs_for[pkg, i2]] = ""
					}
					if(!pkgs_lists[fn, 3, i1, 3] && !has_pkgs_for) {
						conf_err(file_path, ln, ml("no soft dependencies on package", "ru:не найдена ни одна мягкая зависимость от пакета") " `" pkg_raw "\47 " ml("were found in dependency chains of packages marked as manual", "ru:в цепочках зависимостей пакетов, помеченных как manual"))
						continue
					}
					compare_lists(comp_pkgs, line_pkgs_for, "for")
					if(autofix_errors) {
						split_pkg_name_arch(pkg_raw, pkg_raw_splitted)
						list_pkg_add_arch = pkg_raw_splitted["arch"] == dpkg_arch
						if(ffc != "")
							ffc = ffc "\n"
						ffc = ffc pkg_raw " " (pkgs_lists[fn, 3, i1, 3] ? "manual" : "auto")
						if(list_pkgs_for_manual[pkg, 0]) {
							ffc = ffc " for_manual("
							is_first = 1
							for(i2 = 1; i2 <= pkgs_lists[fn, 3, i1, 4, 0]; i2++) {
								list_pkg = normalize_pkg_name(pkgs_lists[fn, 3, i1, 4, i2])
								if(!(list_pkg in line_pkgs_for_manual)) { continue }
								if(!is_first) ffc = ffc " "
								ffc = ffc pkgs_lists[fn, 3, i1, 4, i2]
								delete line_pkgs_for_manual[list_pkg]
								is_first = 0
							}
							for(list_pkg in line_pkgs_for_manual) {
								if(!is_first) ffc = ffc " "
								ffc = ffc list_pkg
								if(list_pkg_add_arch) {
									split_pkg_name_arch(list_pkg, list_pkg_splitted)
									if(list_pkg_splitted["arch"] == "") ffc = ffc ":" dpkg_arch
								}
								is_first = 0
							}
							ffc = ffc ")"
						}
						if(has_pkgs_for) {
							ffc = ffc " for("
							is_first = 1
							for(i2 = 1; i2 <= pkgs_lists[fn, 3, i1, 5, 0]; i2++) {
								list_pkg = normalize_pkg_name(pkgs_lists[fn, 3, i1, 5, i2])
								if(!(list_pkg in line_pkgs_for)) { continue }
								if(!is_first) ffc = ffc " "
								ffc = ffc pkgs_lists[fn, 3, i1, 5, i2]
								delete line_pkgs_for[list_pkg]
								is_first = 0
							}
							for(list_pkg in line_pkgs_for) {
								if(!is_first) ffc = ffc " "
								ffc = ffc list_pkg
								if(list_pkg_add_arch) {
									split_pkg_name_arch(list_pkg, list_pkg_splitted)
									if(list_pkg_splitted["arch"] == "") ffc = ffc ":" dpkg_arch
								}
								is_first = 0
							}
							ffc = ffc ")"
						}
					}
				}
				pkgs_lists[fn, 2] = file_has_errors
				if(autofix_errors && file_has_errors) {
					if(system("mv -f " shell_escape(file_path) " " shell_escape(file_path ".old")))
						exit_code = 1
					else {
						cmd = "cat > " shell_escape(file_path) " || mv -f " shell_escape(file_path ".old") " " shell_escape(file_path)
						print ffc | cmd
						close(file_path)
						if(system("[ -f " shell_escape(file_path ".old") " ]"))
							exit_code = 1
					}
				}
			}
			if(exit_code || verify_only) exit exit_code
			split("", pkgs_deps, ":")
			split("", pkgs_deps_all, ":")
			split("", pkgs_for, ":")
			split("", comp_pkgs, ":")
			split("", list_pkgs_all, ":")
			split("", list_pkgs_manual, ":")
			split("", list_pkgs_for_manual, ":")
			split("", line_pkgs_for, ":")
			split("", line_pkgs_for_manual, ":")
			for(fn = 1; fn <= pkgs_lists[0]; fn++) {
				for(i1 = 1; i1 <= pkgs_lists[fn, 3, 0]; i1++) {
					pkg = normalize_pkg_name(pkgs_lists[fn, 3, i1, 2])
					if(!pkgs_lists[fn, 3, i1, 3] || pkg in pkgs_dup) { continue }
					print pkg
					pkgs_dup[pkg] = ""
				}
			}
			split("", pkgs_dup, ":")
			print ""
			for(pkg in list_pkgs_included) {
				if(!(pkg in pkgs_local)) print pkg
			}
		}' "$confdir" "$dpkg_arch" "$overlapping_install" "$2" "$3" "$4") &&
	pkgs_list_manual=$(putv pkgs_list_install | LC_ALL=C awk '{
		if($0 == "") exit
		print $0
	}') &&
	pkgs_list_install=$(putv pkgs_list_install | LC_ALL=C awk 'BEGIN { do_out = 0 } {
		if($0 == "") { do_out = 1; next }
		if(do_out) print $0
	}')
}
isdirempty() {
	[ -d "$1" ] || {
		err "isdirempty: $(eawk 'BEGIN {
			print ml("directory", "ru:каталог") " `" ARGV[1] "\47 " ml("does not exist", "ru:не существует")
		}' "$1")"
		return 2
	}
	isdirempty__buf=$(
		cd "$1" 2>&3 &&
		find . -path './*' -prune -exec sh -c 'echo .; kill -INT "$PPID"' \; 2>&3
	) 3>&2 2>/dev/null
	case $? in
	0) [ -z "$isdirempty__buf" ] && return 0;;
	*) [ -z "$isdirempty__buf" ] && return 2;;
	esac
	return 1
}
mergecp() { (
	UID=$(id -u)
	if [ -h "$1" ]; then stype=l
	elif [ -d "$1" ]; then stype=d
	elif [ -e "$1" ]; then stype=f
	else exit 0; fi
	if [ -h "$2" ]; then dtype=l
	elif [ -d "$2" ]; then dtype=d
	elif [ -e "$2" ]; then dtype=f
	else dtype=; fi
	normalize_path "$2" DEST_PATH || exit
	if [ "$stype" = d ]; then
		target_dir=$DEST_PATH
	else
		[ "$DEST_PATH" = / ] &&
			err_ml 1 'mergecp: destination path cannot be "/" if source is not a directory' 'ru:mergecp: путь назначения не может быть "/", если источник не является каталогом'
		normalize_path "$DEST_PATH/.." target_dir || exit
	fi
	unset -v BACKUP_PATH
	[ $# -ge 3 ] && {
		normalize_path "$3" BACKUP_PATH || exit
		[ -n "$dtype" ] && [ "$dtype" != d ] && [ "$BACKUP_PATH" = / ] &&
			err_ml 1 'mergecp: backup path cannot be "/" if destination is not a directory' 'ru:mergecp: путь резервной копии не может быть "/", если назначение не является каталогом'
		if [ "$stype$dtype" = dd ]; then
			[ -d "$BACKUP_PATH" ] || {
				mkdir -p "$BACKUP_PATH" &&
				chmod --reference="$DEST_PATH" "$BACKUP_PATH" &&
				{ [ ":$UID" != :0 ] || chown --reference="$DEST_PATH" "$BACKUP_PATH"; }
			} || exit
		elif [ -n "$dtype" ] && ! {
			[ -h "$BACKUP_PATH" ] || [ -e "$BACKUP_PATH" ]
		}; then
			normalize_path "$BACKUP_PATH/.." backup_path_parent || exit
			[ -d "$backup_path_parent" ] || mkdir -p "$backup_path_parent" || exit
			cp -dfpTR -- "$2" "$BACKUP_PATH" || exit
		fi
	}
	old_ifs=$IFS; IFS=/
	unset -v dir_path
	for elem in ${target_dir#/}; do
		dir_path=$dir_path/$elem
		[ -d "$dir_path" ] && continue
		if [ -h "$dir_path" ] || [ -e "$dir_path" ]; then
			rm -f "$dir_path" || exit
		fi
		mkdir "$dir_path" || exit
	done
	IFS=$old_ifs
	[ "$stype$dtype" = dd ] || {
		[ -z "$dtype" ] || rm -rf "$DEST_PATH" || exit
		cp -dfpTR -- "$1" "$DEST_PATH"
		exit
	}
	cd -- "$1" || exit
	export DEST_PATH BACKUP_PATH UID || exit
	find . ! -path . -exec sh -c '
		interrupt() { kill -INT "$PPID"; exit; }
		make_backup() { :; }
		[ -n "$BACKUP_PATH" ] && make_backup() {
			{ [ -z "$dtype" ] || [ -h "$BACKUP_PATH$path" ] || [ -e "$BACKUP_PATH$path" ]; } && return
			old_ifs=$IFS; IFS=/
			unset -v dir_path
			for elem in ${path%/*}; do
				dir_path=$dir_path/$elem
				[ -h "$BACKUP_PATH$dir_path" ] && { IFS=$old_ifs; return; }
				if [ -e "$BACKUP_PATH$dir_path" ]; then
					[ -d "$BACKUP_PATH$dir_path" ] || { IFS=$old_ifs; return; }
				else
					mkdir "$BACKUP_PATH$dir_path" &&
					chmod --reference="$DEST_PATH$dir_path" "$BACKUP_PATH$dir_path" &&
					{ [ ":$UID" != :0 ] || chown --reference="$DEST_PATH$dir_path" "$BACKUP_PATH$dir_path"; }
				fi || interrupt
			done
			IFS=$old_ifs
			cp -dfpTR -- "$DEST_PATH/$path" "$BACKUP_PATH/$path" || interrupt
		}
		path=${0#.}
		if [ -h "$0" ]; then stype=l
		elif [ -d "$0" ]; then stype=d
		else stype=f; fi
		if [ -h "$DEST_PATH$path" ]; then dtype=l
		elif [ -d "$DEST_PATH$path" ]; then dtype=d
		elif [ -e "$DEST_PATH$path" ]; then dtype=f
		else dtype=; fi
		[ "$stype" = d ] || {
			make_backup
			rm -rf "$DEST_PATH$path" || interrupt
			cp -dfpT -- "$0" "$DEST_PATH$path" || interrupt
			exit
		}
		if [ -z "$dtype" ]; then
			mkdir "$DEST_PATH$path" || interrupt
		elif [ "$dtype" != d ]; then
			make_backup
			rm -f "$DEST_PATH$path" || interrupt
			mkdir "$DEST_PATH$path" || interrupt
		fi
		{
			chmod --reference="$0" "$DEST_PATH$path" &&
			{ [ ":$UID" != :0 ] || chown --reference="$0" "$DEST_PATH$path"; }
		} || interrupt
	' {} \;
) }
rollback_rm() { (
	rollback_path=/var/local/lib/$program_name/rollback/$1
	cd "$rollback_path" || exit
	[ -f files ] || exit 0
	trap '' $SIGNALS
	eawk '
		function err_syntax() {
			err("invalid syntax `" $0 "\47 on line " NR " in file `" ARGV[1] "\47", 1)
		}
		function add_file(is_at_end) {
			if(!files[0]) return
			if(path "/" ~ /\57\.?\.?\57/)
				err("invalid path `" path "\47 on line " (NR - !is_at_end) " in file `" ARGV[1] "\47", 1)
			if(path == "/")
				err("attempt to handle \"/\" on line " (NR - !is_at_end) " in file `" ARGV[1] "\47", 1)
			if(rollback_path_len && \
				substr(path, 1, rollback_path_len + 1) != rollback_path "/" && \
				(rollback_dir_contents || path != rollback_path) \
			) {
				print (type == "d" ? "d" : type " " md5sum) "/" path > "files.new"
				files[0]--
				return
			}
			files[files[0], 1] = type
			files[files[0], 2] = md5sum
			files[files[0], 3] = path
		}
		BEGIN {
			ARGC = 2
			rollback_path = ARGV[3]
			rollback_path_len = length(rollback_path)
			rollback_dir_contents = ARGV[4] + 0
		} {
			pos = index($0, "//")
			if(pos) {
				if(pos == 1) err_syntax()
				add_file()
				files[0]++
				split(substr($0, 1, pos - 1), splitted)
				type = splitted[1]
				md5sum = splitted[2]
				if(type != "d" && type != "f" && type != "l") err_syntax()
				if(md5sum == "" && type != "d") err_syntax()
				path = substr($0, pos + 1)
			} else path = path "\n" $0
		} END {
			if(exit_code) exit exit_code
			add_file(1)
			close("files.new")
			gsub(/\n[\t ]+/, "\n", ARGV[5])
			for(i = files[0]; i > 0; i--) {
				if(system( \
					"backup_path=" shell_escape(ARGV[2]) "\n" \
					"ltype=" shell_escape(files[i, 1]) "\n" \
					"lmd5sum=" shell_escape(files[i, 2]) "\n" \
					"path=" shell_escape(files[i, 3]) "\n" \
					ARGV[5] \
				)) exit 1
			}
		}' "$rollback_path/files" "$rollback_backup_path" "$2" "$3" '
		if [ -h "$path" ]; then ctype=l
		elif [ -d "$path" ]; then ctype=d
		elif [ -e "$path" ]; then ctype=f
		else ctype=; fi
		if [ -z "$ctype" ]; then
			if [ "$ltype" = d ]; then
				printf %s\\n "$ltype/$path"
			else
				printf %s\\n "$ltype $lmd5sum/$path"
			fi >> "$backup_path/removed"
			exit
		elif [ "$ltype" = "$ctype" ]; then
			if [ "$ctype" = d ]; then
				make_backup=0
			else
				make_backup=1
				{
					cmd5sum=$(
						if [ "$ctype" = f ]; then
							md5sum "$path"
						else
							dest=$(readlink "$path" && echo .) &&
							eval "dest=$(LC_ALL=C awk -- '\''BEGIN {
								if(!sub(/\n\.$/, "", ARGV[1])) exit 1
								gsub(/\47/, "\47\134\47\47", ARGV[1])
								print "\47" ARGV[1] "\47"
							}'\'' "$dest" || echo "exit 1")" &&
							printf %s "$dest" | md5sum
						fi
					) && [ -n "$cmd5sum" ] && cmd5sum="${cmd5sum%% *}"
				} || exit
				[ ":$cmd5sum" = ":$lmd5sum" ] && make_backup=0
			fi
		fi
		{ [ -h "$backup_path/files$path" ] || [ -e "$backup_path/files$path" ]; } && make_backup=0
		[ $make_backup -eq 1 ] && {
			old_ifs=$IFS; IFS=/
			target_dir=${path%/*}
			unset -v dir_path
			for elem in ${target_dir#/}; do
				dir_path=$dir_path/$elem
				if [ -h "$backup_path/files$dir_path" ]; then
					make_backup=0; break
				elif [ -d "$backup_path/files$dir_path" ]; then
					continue
				elif [ -e "$backup_path/files$dir_path" ]; then
					make_backup=0; break
				fi
				{
					mkdir -- "$backup_path/files$dir_path" &&
					chmod --reference="$dir_path" "$backup_path/files$dir_path" &&
					chown --reference="$dir_path" "$backup_path/files$dir_path"
				} || exit
			done
			IFS=$old_ifs
		}
		[ $make_backup -eq 1 ] && {
			if [ "$ctype" = d ]; then
				mkdir -- "$backup_path/files$path" &&
				chmod --reference="$path" "$backup_path/files$path" &&
				chown --reference="$path" "$backup_path/files$path"
			else
				cp -dfpT "$path" "$backup_path/files$path"
			fi || exit
		}
		if [ "$ctype" = d ]; then
			buf=$(
				cd "$path" 2>&3 &&
				find . -path '\''./*'\'' -prune -exec sh -c '\''echo .; kill -INT "$PPID"'\'' \; 2>&3
			) 3>&2 2>/dev/null
			case $? in
			0) [ -n "$buf" ] || rmdir "$path";;
			*) [ -n "$buf" ];;
			esac
		else
			rm -f "$path"
		fi || exit
		exit 0' || { rm -f files.new; exit 1; }
		if [ -n "$2" ]; then
			mv -f files.new files || { rm -f files.new; exit 1; }
		else
			rm -f files
		fi
) }
reset_perms_owners() {
	normalize_path "$1" reset_perms_owners__path &&
	find "$reset_perms_owners__path" ! -type l -exec sh -c '
		if [ -d "$0" ]; then
			chmod 0755 "$0"
		else
			chmod 0644 "$0"
		fi || kill -INT "$PPID"
	' {} \; && {
		[ "$(id -u)" != 0 ] || chown -R root:root "$reset_perms_owners__path"
	}
}
run_parts() (
	[ -d "$1" ] || err 2 "$(eawk 'BEGIN {
		print ml("directory", "ru:каталог") " `" ARGV[1] "\47 " ml("does not exist", "ru:не существует")
	}' "$1")"
	old_pwd=$PWD
	cd -- "$1" || exit 2
	old_pwd=$old_pwd find -L . -path './*' -prune -type f -exec sh -c '
		interrupt() { kill -INT "$PPID"; exit; }
		'"$2"'
		script_path=$PWD/${0#./}
		cd "$old_pwd" || interrupt
		unset -v old_pwd
		! [ -x "$script_path" ] || "$script_path" < /dev/null || interrupt
	' {} \; || exit 1
)
apt_get_wrapper() {
	apt-get -y \
		--show-progress \
		--no-install-recommends \
		--purge \
		-oAPT::Install-Suggests=false \
		-oDpkg::Progress-Fancy=true \
		-oDebug::pkgProblemResolver=true \
		"$@"
}
do_install__set_pkgs_state() {
	apt-cache dumpavail | dpkg --update-avail &&
	dpkg --clear-selections &&
	putv "$1" | sed 's/$/ install/' | dpkg --set-selections
}
do_install__reset_pkgs_state() {
	dpkg --clear-avail || set 1
	{
		do_install__buf=$(dpkg --get-selections) &&
		dpkg --clear-selections &&
		putv do_install__buf |
			LC_ALL=C awk '{ print $1 " install" }' | dpkg --set-selections
	} || set 1
	unset -v do_install__buf
	return $1
}
do_install__get_pkgs_state_md5sum() {
	eval "$1=\$(dpkg --get-selections | md5sum); $1=\${$1%% *}; [ -n \"\$$1\" ]"
}
do_install__mark_pkgs() {
	[ $simulate_install -eq 0 ] &&
		log_ml 'setting auto/manual packages markings ...' 'ru:установка auto/manual маркировок пакетов ...'
	{
		[ $overlapping_install -ne 0 ] || ! [ -e "$confdir/common/unmanaged-packages" ]
		load_unmanaged_pkgs=$?
		[ $load_unmanaged_pkgs -ne 0 ] && {
			sed -n '/^$/!p' "$confdir/common/unmanaged-packages" || { puts; puts 0; exit; }
		}
		puts
		puts 1
		{ [ $load_unmanaged_pkgs -ne 0 ] || [ $overlapping_install -ne 0 ]; } && {
			{
				buf=$(dpkg --get-selections) &&
				putv buf | sed -n '/^$/!p'
			} || { puts; puts 0; exit; }
			unset -v buf
		}
		puts
		puts 1
		putv pkgs_list_manual
		puts
		buf=$(apt-mark showmanual) || { puts; puts 0; exit; }
		putv buf | sed -n '/^$/!p'
		unset -v buf
		puts
		puts 1
	} | eawk '
	function exec_cmd(cmd, cmd_part) {
		if(system(cmd cmd_part))
			err(ml("command", "ru:команда") " `" cmd "\47 " ml("failed", "ru:завершилась с ошибкой"), 1)
	}
	function process_pkgs(type,    pkg, local) {
		if(pkg != "") {
			if(simulate_install) {
				if(local["has_pkgs"])
					printf(", %s", pkg)
				else
					printf("%s: %s", ml("Mark packages as", "ru:Пометить пакеты как") " " type, pkg)
			} else {
				local["cmd_pkgs_count"]++
				local["cmd_part"] = local["cmd_part"] " " shell_escape(pkg)
				if(local["cmd_pkgs_count"] == 100) {
					exec_cmd("apt-mark " type, local["cmd_part"])
					local["cmd_part"] = ""
					local["cmd_pkgs_count"] = 0
				}
			}
			local["has_pkgs"] = 1
			return
		}
		local["cmd_part"] = ""
		local["has_pkgs"] = local["cmd_pkgs_count"] = 0
		if(type == "manual") {
			for(pkg in pkgs_manual_new) {
				if(pkg in pkgs_manual_cur) { continue }
				process_pkgs(type, pkg, local)
			}
		} else {
			for(pkg in pkgs_manual_cur) {
				if(pkg in pkgs_manual_new || pkg in unmanaged_pkgs) { continue }
				process_pkgs(type, pkg, local)
			}
		}
		if(simulate_install) {
			if(local["has_pkgs"]) print ""
		} else if(local["cmd_pkgs_count"])
			exec_cmd("apt-mark " type, local["cmd_part"])
	}
	BEGIN {
		state = 1
		simulate_install = ARGV[1] + 0
		overlapping_install = ARGV[2] + 0
		dpkg_arch = ARGV[3]
	} {
		if(state == 1) {
			if($0 == "") { state++; next }
			unmanaged_pkgs_regexps[$0] = ""
		} else if(state == 2) {
			if(!$0) { exit_code = 1; exit }
			state++
		} else if(state == 3) {
			if($0 == "") { state++; next }
			pkg = $1
			split_pkg_name_arch(pkg, splitted)
			if(splitted["arch"] == dpkg_arch) pkg = splitted["name"]
			if(overlapping_install || match_any_of(splitted["name"], unmanaged_pkgs_regexps))
				unmanaged_pkgs[pkg] = ""
		} else if(state == 4) {
			if(!$0) { exit_code = 1; exit }
			state++
		} else if(state == 5) {
			if($0 == "") { state++; next }
			split_pkg_name_arch($0, splitted)
			if(splitted["arch"] == dpkg_arch) $0 = splitted["name"]
			pkgs_manual_new[$0] = ""
		} else if(state == 6) {
			if($0 == "") { state++; next }
			pkgs_manual_cur[$0] = ""
		} else if(state == 7) {
			if(!$0) exit_code = 1
			exit
		}
	} END {
		if(exit_code) exit exit_code
		process_pkgs("manual")
		process_pkgs("auto")
	}' "$simulate_install" "$overlapping_install" "$dpkg_arch"
}
do_install__after_pkgs_install() {
	log_ml 'purging automatically installed packages that are not required to satisfy dependencies of other packages ...' 'ru:очистка автоматически установленных пакетов, не требующихся для удовлетворения зависимостей других пакетов ...'
	apt_get_wrapper autoremove || return 1

	log_ml 'cleaning downloaded packages files ...' 'ru:очистка загруженных файлов пакетов ...'
	apt-get -y clean || return 1

	log_ml 'removing unused architectures ...' 'ru:удаление неиспользуемых архитектур ...'
	eawk '
	function cmd_err(cmd) {
		err(ml("command", "ru:команда") " `" cmd "\47 " ml("failed", "ru:завершилась с ошибкой"), 1)
	}
	BEGIN {
		cmd_main_part = "dpkg --print-foreign-architectures"
		cmd = cmd_main_part "; echo $?"
		while((cmd | getline) > 0) {
			if(f[1] != "") remove_archs[f[1]] = ""
			f[1] = $1
		}
		close(cmd)
		if(f[1] + 0) cmd_err(cmd_main_part)
		cmd_main_part = "dpkg --get-selections"
		cmd = cmd_main_part "; echo $?"
		split("", f, ":")
		while((cmd | getline) > 0) {
			if(f[2] == "install" && match(f[1], /:[a-zA-Z0-9.+-]+$/)) {
				arch = substr(f[1], RSTART + 1)
				if(arch in remove_archs) delete remove_archs[arch]
			}
			f[1] = $1; f[2] = $2
		}
		close(cmd)
		if(f[1] + 0) cmd_err(cmd_main_part)
		for(arch in remove_archs) {
			cmd = "dpkg --remove-architecture " shell_escape(arch)
			if(system(cmd)) cmd_err(cmd)
		}
	}'
}
do_install() {
	unset -v \
		pkgs_list_install \
		pkgs_list_manual
	do_install__sources_list_changed=0
	do_install__sources_list_exist=0

	{
		check_is_root &&
		check_os_release &&
		check_os_arch &&
		checkutil dpkg dpkg-deb apt-get apt-cache apt-mark md5sum readlink &&
		check_gnu_coreutils du cp chmod chown &&
		sanitize_scripts_env &&
		get_env_path_extended &&
		putv conf | eawk '{
			if(!conf_parse_line()) next
			conf_add(conf)
		} END {
			print "common"
			for(i = 1; i <= conf["/prop/components", 0]; i++)
				print "components/" conf["/prop/components", i]
		}' | while gets component; do
			for file in preinst postinst; do
				! [ -f "$confdir/$component/$file" ] || [ -x "$confdir/$component/$file" ] ||
				err 1 "$(eawk 'BEGIN {
					print ml("file", "ru:файл") " `" ARGV[1] "\47 " ml("does not have execute permission", "ru:не имеет права на выполнение")
				}' "$confdir/$component/$file")"
			done
		done
	} || return 1
	[ -f /etc/apt/sources.list ] && do_install__sources_list_exist=1

	do_install__onexit() { :; }
	onexit() {
		set 0
		log_ml 'executing final actions ...' 'ru:выполнение завершающих действий ...'
		unset -v \
			do_install__buf \
			do_install__pkgs_state_md5sum_new \
			do_install__pkgs_state_md5sum_old \
			do_install__local_pkgs \
			do_install__local_pkgs_info \
			do_install__sources_list_new \
			pkgs_list_manual
		do_install__onexit || set 1
		[ -z "$pkgs_list_install" ] || {
			{ [ $simulate_install -eq 1 ] || do_install__after_pkgs_install; } &&
			do_install__reset_pkgs_state &&
			unset -v pkgs_list_install
		} || set 1
		[ $simulate_install -eq 1 ] || {
			rm -rf "/var/local/lib/$program_name/prep" "/var/local/lib/$program_name/tmp" &&
			release_lock "/var/local/lib/$program_name/lock"
		} || set 1
		onexit() { :; }
		return $1
	}

	[ $simulate_install -eq 1 ] || {
		mkvardir &&
		get_lock "/var/local/lib/$program_name/lock" 1 1 &&
		{ ! [ -d "/var/local/lib/$program_name/rollback" ] || {
			log_ml 'rolling back a previously installed configuration ...' 'ru:откат установленной ранее конфигурации ...'
			"/usr/local/bin/$program_name" rollback -yL
		}; } &&
		rm -rf "/var/local/lib/$program_name/tmp"
	} || { onexit; return 1; }

	do_install__local_pkgs=$(
		{
			puts common
			get_sel_components_dirs 1
		} | while gets dir; do
			dir=$dir/pkgs
			[ -d "$confdir/$dir" ] || continue
			cd "$confdir/$dir" || exit
			buf=$(find . -path './*' -prune) || exit
			putv buf | LC_ALL=C awk -- 'BEGIN { ARGC = 1 } {
				print ARGV[1] "/" substr($0, index($0, "/") + 1)
			}' "$dir" || exit
		done
	) || { onexit; return 1; }

	[ $simulate_install -eq 0 ] && [ -n "$do_install__local_pkgs" ] && {
		log_ml 'installing local packages ...' 'ru:установка локальных пакетов ...'
		putv do_install__local_pkgs | while gets pkg_path; do
			log "$(eawk 'BEGIN {
				print ml("installing package", "ru:установка пакета") " `" ARGV[1] "\47 ..."
			}' "$pkg_path")"
			pkg_abspath=$confdir/$pkg_path
			if [ -f "$pkg_abspath" ]; then
				dpkg --force-depends --force-breaks --force-conflicts -i "$pkg_abspath"
			else
				{
					mkvardir tmp &&
					cp -dfpRT "$pkg_abspath" "/var/local/lib/$program_name/prep" &&
					reset_perms_owners "/var/local/lib/$program_name/prep" &&
					cd "/var/local/lib/$program_name/prep"
				} || exit
				for filename in preinst postinst prerm postrm prebuild; do
					[ -f "DEBIAN/$filename" ] || continue
					chmod +x "DEBIAN/$filename" || exit
				done
				[ -f DEBIAN/prebuild ] && {
					PATH=$env_path_extended \
					SCRIPT_NAME=prebuild \
					CONFDIR=$confdir \
					PACKAGE=$pkg_path \
					PREPDIR=/var/local/lib/$program_name/prep \
					TEMP=/var/local/lib/$program_name/tmp \
					TMP=/var/local/lib/$program_name/tmp \
					TMPDIR=/var/local/lib/$program_name/tmp \
					./DEBIAN/prebuild < /dev/null ||
					err 1 "$(eawk 'BEGIN {
						print ml("script", "ru:скрипт") " `prebuild\47 " ml("completed with error, exit code:", "ru:завершился с ошибкой, код завершения:") " " ARGV[1]
					}' $?)"
					{
						rm -f DEBIAN/prebuild &&
						rm -rf "/var/local/lib/$program_name/tmp" &&
						mkvardir tmp
					} || exit
				}
				buf=$(
					find . -path './DEBIAN/*' -prune -o -type f -exec \
						sh -c 'md5sum -- "$0" || kill -INT "$PPID"' {} \;
				) &&
				putv buf | LC_ALL=C awk '{
					sum = $1
					if(!sub(/^[ \t]*[^ \t]+[ \t]+\.\//, "")) next
					print sum "  " $0
				}' | LC_ALL=C sort > DEBIAN/md5sums &&
				buf=$(cat DEBIAN/control) && {
					du -sx --exclude DEBIAN . &&
					putv buf
				} | LC_ALL=C awk 'BEGIN { is_found = 0 } {
					if(NR == 1) size = $1
					else if($0 ~ /^Installed-Size: /) {
						is_found = 1
						print "Installed-Size: " size
					} else print $0
				} END {
					if(!is_found) print "Installed-Size: " size
				}' > DEBIAN/control &&
				cd .. &&
				dpkg-deb -b prep tmp/package.deb &&
				rm -rf prep &&
				dpkg --force-depends --force-breaks --force-conflicts -i tmp/package.deb &&
				rm -rf tmp
			fi || exit
		done || { onexit; return 1; }
	}

	log_ml 'building a list of installing packages ...' 'ru:построение списка устанавливаемых пакетов ...'
	[ $simulate_install -eq 1 ] && {
		do_install__local_pkgs_info=$(
			[ -z "$do_install__local_pkgs" ] ||
			putv do_install__local_pkgs | while gets pkg_path; do
				pkg_path=$confdir/$pkg_path
				if [ -f "$pkg_path" ]; then
					buf=$(dpkg-deb -f "$pkg_path")
				else
					buf=$(cat "$pkg_path/DEBIAN/control")
				fi || exit
				putv buf | sed -n '/^$/!p'
				puts
			done
		) || { onexit; return 1; }
	}
	unset -v do_install__local_pkgs

	do_install__onexit() {
		set 0
		[ $do_install__sources_list_changed -eq 1 ] && {
			if [ $do_install__sources_list_exist -eq 1 ]; then
				putvn do_install__sources_list_old > /etc/apt/sources.list || set 1
				unset -v do_install__sources_list_old
			else
				rm -f /etc/apt/sources.list || set 1
			fi
		}
		do_install__onexit() { :; }
		return $1
	}
	do_install__buf=$(
		{
			puts common
			get_sel_components_dirs 1
		} | eawk 'BEGIN {
			file_path = "/etc/apt/sources.list"
			print_leading_newline = 0
			if(!system("[ -f " shell_escape(file_path) " ]")) {
				while((retval = getline < file_path) > 0) {
					print_leading_newline = sub(/#.*/, "")
					gsub(/[\t\v\f\r ]+/, " ")
					sub(/^ /, ""); sub(/ $/, "")
					if($0 != "") {
						print_leading_newline = 1
						dup[$0] = ""
					}
				}
				close(file_path)
				if(retval < 0)
					err(ml("unable to read file", "ru:невозможно прочитать файл") " `" file_path "\47", 1)
			}
		} {
			file_path = ARGV[1] "/" $0 "/apt-sources"
			if(system("[ -f " shell_escape(file_path) " ]")) next
			state = 0
			while((retval = getline < file_path) > 0) {
				sub(/^[\t\v\f\r ]+/, "")
				pos = index($0, "#")
				if(pos) {
					if(state != 1) comment = ""
					state = 1
					if(comment != "") comment = comment "\n"
					comment = comment substr($0, pos)
					if(pos == 1) { continue }
					$0 = substr($0, 1, pos - 1)
				}
				gsub(/[\t\v\f\r ]+/, " "); sub(/ $/, "")
				if($0 == "") {
					state = 0
					continue
				}
				if(state != 3) state = 2
				if($0 in dup) { continue }
				dup[$0] = ""
				if(print_leading_newline && state == 2) print ""
				state = 3
				print_leading_newline = 1
				if(comment != "") print comment
				print $0
				comment = ""
			}
			close(file_path)
			if(retval < 0)
				err(ml("unable to read file", "ru:невозможно прочитать файл") " `" file_path "\47", 1)
		}' "$confdir" && echo .
	) || { onexit; return 1; }
	do_install__buf=${do_install__buf%.}
	[ -n "$do_install__buf" ] && {
		if [ $do_install__sources_list_exist -eq 1 ]; then
			do_install__sources_list_old=$(cat /etc/apt/sources.list && echo .) || { onexit; return 1; }
			do_install__sources_list_old=${do_install__sources_list_old%.}
			do_install__sources_list_new=$do_install__sources_list_old$do_install__buf
		else
			do_install__sources_list_new=$do_install__buf
		fi
		unset -v do_install__buf
		log_ml 'adding repositories to /etc/apt/sources.list ...' 'ru:добавление репозиториев в /etc/apt/sources.list ...'
		do_install__sources_list_changed=1
		putvn do_install__sources_list_new > /etc/apt/sources.list || { onexit; return 1; }
	}

	pkgs_list_load sel "$([ $simulate_install -eq 1 ] && puts do_install__local_pkgs_info)" || { onexit; return 1; }
	unset -v do_install__local_pkgs_info
	do_install__onexit || { onexit; return 1; }

	if [ -n "$pkgs_list_install" ]; then
		log_ml 'applying packages state ...' 'ru:применение состояния пакетов ...'
		do_install__set_pkgs_state pkgs_list_install || { onexit; return 1; }

		[ $simulate_install -eq 0 ] &&
			log_ml 'installing packages ...' 'ru:установка пакетов ...'
		do_install__cmd=apt_get_wrapper
		[ $simulate_install -eq 1 ] &&
			do_install__cmd=$do_install__cmd' -s'
		do_install__cmd=$do_install__cmd' dselect-upgrade && do_install__mark_pkgs'
		if [ $simulate_install -eq 1 ] && [ $is_interactive -eq 1 ] && checkutil -s less; then
			do_install__buf=$(eval " $do_install__cmd" 2>&1) || { onexit; return 1; }
			putv do_install__buf | less
			unset -v do_install__buf
		else
			eval "$do_install__cmd" || { onexit; return 1; }
		fi
		unset -v pkgs_list_manual

		do_install__get_pkgs_state_md5sum do_install__pkgs_state_md5sum_old || { onexit; return 1; }
	else
		log_ml 'no installation or removal of any packages required' 'ru:не требуется установка или удаление каких-либо пакетов'
	fi
	[ $simulate_install -eq 1 ] && { onexit; return; }

	{
		{ [ -d /usr/local/bin ] || mkdir -p /usr/local/bin; } &&
		cat -- "$0" > "/usr/local/bin/$program_name" &&
		chmod +x "/usr/local/bin/$program_name" &&
		mkvardir rollback &&
		putv program_version > "/var/local/lib/$program_name/rollback/version"
	} || { onexit; return 1; }
	putv conf | eawk '
	function print_conf_values(component_path,    i) {
		print component_path
		for(i = 1; i <= conf["/conf/" component_path, 0]; i++) {
			print component_path "/" conf["/conf/" component_path, i] "=" conf["/conf/" component_path "/" conf["/conf/" component_path, i]]
		}
	}
	{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		order_path = "/prop/components-install-order"
		for(i = conf[order_path, 0]; i > 0; i--) {
			if(!(conf["/conf/components/" conf[order_path, i]] + 0)) { continue }
			print_conf_values("components/" conf[order_path, i])
		}
		print_conf_values("common")
	}' > "/var/local/lib/$program_name/rollback/config" || { onexit; return 1; }
	do_install__onexit() {
		set 0
		rm -rf "/var/local/lib/$program_name/prep" || set 1
		do_install__onexit() { :; }
		return $1
	}
	{
		{ [ $do_install__sources_list_changed -eq 1 ] || [ -d "$confdir/common" ]; } && puts common
		get_sel_components_dirs
	} | while gets component; do
		log "$(eawk 'BEGIN {
			print ml("configuring component", "ru:настройка компонента") " `" ARGV[1] "\47 ..."
		}' "$component")"
		(
			if [ "$component" = common ] && ! [ -d "$confdir/common" ]; then
				component_exist=0
			else
				component_exist=1
			fi
			[ $component_exist -eq 0 ] || {
				cd "$confdir/$component" || exit
				eval "$(
					putv conf | eawk '{
						if(!conf_parse_line()) next
						conf_add(conf)
					} END {
						for(i = 1; i <= conf["/conf/" ARGV[1], 0]; i++)
							print "export CONF_" toupper(conf["/conf/" ARGV[1], i]) "=" shell_escape(conf["/conf/" ARGV[1] "/" conf["/conf/" ARGV[1], i]]) " || exit"
					}' "$component" || puts 'exit 1'
				)"
			}
			rollback_path=/var/local/lib/$program_name/rollback/$component
			export \
				PATH="$env_path_extended" \
				CONFDIR="$confdir" \
				PREPDIR="/var/local/lib/$program_name/prep" \
				COMPONENT="$component" \
				TEMP="/var/local/lib/$program_name/tmp" \
				TMP="/var/local/lib/$program_name/tmp" \
				TMPDIR="/var/local/lib/$program_name/tmp" || exit
			if [ $component_exist -eq 1 ] && [ -d files ]; then
				cp -dfRT files "$PREPDIR" &&
				reset_perms_owners "$PREPDIR"
			else
				mkvardir prep
			fi || exit
			[ "$component" != common ] || [ $do_install__sources_list_changed -eq 0 ] || {
				mkdir -p "$PREPDIR/etc/apt" &&
				putvn do_install__sources_list_new > "$PREPDIR/etc/apt/sources.list" &&
				{ [ $do_install__sources_list_exist -eq 0 ] || {
					chmod --reference=/etc/apt/sources.list "$PREPDIR/etc/apt/sources.list" &&
					chown --reference=/etc/apt/sources.list "$PREPDIR/etc/apt/sources.list"
				}; }
			} || exit
			mkvardir "rollback/$component/backup" || exit
			[ $component_exist -eq 1 ] && {
				for filename in prerm postrm; do
					[ -f "$filename" ] || continue
					cat "$filename" > "/var/local/lib/$program_name/rollback/$component/$filename" || exit
					chmod +x "/var/local/lib/$program_name/rollback/$component/$filename" || exit
				done
				[ -f preinst ] && {
					mkvardir tmp || exit
					SCRIPT_NAME=preinst ./preinst < /dev/null ||
					err 1 "$(eawk 'BEGIN {
						print ml("script", "ru:скрипт") " `preinst\47 " ml("completed with error, exit code:", "ru:завершился с ошибкой, код завершения:") " " ARGV[1]
					}' $?)"
					rm -rf "/var/local/lib/$program_name/tmp" || exit
				}
			}
			! [ -d "$PREPDIR" ] || isdirempty "$PREPDIR" || (
				trap '' $SIGNALS
				cd "$PREPDIR" || exit
				export BACKUP_PATH="$rollback_path/backup" || exit
				find . ! -path . -exec sh -c '
					interrupt() { kill -INT "$PPID"; exit; }
					path=${0#.}
					if [ -h "$0" ]; then stype=l
					elif [ -d "$0" ]; then stype=d
					else stype=f; fi
					if [ -h "$path" ]; then dtype=l
					elif [ -d "$path" ]; then dtype=d
					elif [ -e "$path" ]; then dtype=f
					else dtype=; fi
					[ "$stype$dtype" = dd ] && exit
					unset -v md5sum
					[ "$stype" = d ] || {
						md5sum=$(
							if [ "$stype" = f ]; then
								md5sum "$0"
							else
								dest=$(readlink "$0" && echo .) &&
								eval "dest=$(LC_ALL=C awk -- '\''BEGIN {
									if(!sub(/\n\.$/, "", ARGV[1])) exit 1
									gsub(/\47/, "\47\134\47\47", ARGV[1])
									print "\47" ARGV[1] "\47"
								}'\'' "$dest" || echo interrupt)" &&
								printf %s "$dest" | md5sum
							fi
						) && [ -n "$md5sum" ] && md5sum=" ${md5sum%% *}"
					} || interrupt
					[ -z "$dtype" ] || {
						old_ifs=$IFS; IFS=/
						target_dir=${path%/*}
						unset -v dir_path
						for elem in ${target_dir#/}; do
							dir_path=$dir_path/$elem
							! [ -h "$BACKUP_PATH$dir_path" ] && [ -d "$BACKUP_PATH$dir_path" ] && continue
							{
								mkdir "$BACKUP_PATH$dir_path" &&
								chmod --reference="$dir_path" "$BACKUP_PATH/$dir_path" &&
								chown --reference="$dir_path" "$BACKUP_PATH/$dir_path"
							} || interrupt
						done
						IFS=$old_ifs
						cp -dfpRT "$path" "$BACKUP_PATH$path" &&
						rm -rf "$path"
					} || interrupt
					printf %s\\n "$stype$md5sum/$path" || interrupt
					if [ "$stype" = d ]; then
						mkdir "$path" &&
						chmod --reference=".$path" "$path" &&
						chown --reference=".$path" "$path"
					else
						cp -dfpT ".$path" "$path" &&
						rm -f ".$path"
					fi || interrupt
				' {} \; > "/var/local/lib/$program_name/rollback/$component/files" || exit
			) || exit
			isdirempty "$rollback_path/backup" && {
				rmdir "$rollback_path/backup" || exit
			}
			rm -rf "$PREPDIR" || exit
			unset -v PREPDIR
			[ $component_exist -eq 1 ] && [ -f postinst ] && {
				mkvardir tmp || exit
				SCRIPT_NAME=postinst ./postinst < /dev/null ||
				err 1 "$(eawk 'BEGIN {
					print ml("script", "ru:скрипт") " `postinst\47 " ml("completed with error, exit code:", "ru:завершился с ошибкой, код завершения:") " " ARGV[1]
				}' $?)"
				rm -rf "/var/local/lib/$program_name/tmp" || exit
			}
			isdirempty "$rollback_path" && {
				rmdir "$rollback_path" || exit
			}
			true
		) || err 1 "$(eawk 'BEGIN {
			print ml("an error occured while configuring component", "ru:произошла ошибка при настройке компонента") " `" ARGV[1] "\47"
		}' "$component")"
	done || { onexit; return 1; }
	[ -d "/var/local/lib/$program_name/rollback/components" ] && isdirempty "/var/local/lib/$program_name/rollback/components" && {
		rmdir "/var/local/lib/$program_name/rollback/components" || { onexit; return 1; }
	}
	do_install__onexit || { onexit; return 1; }

	[ -n "$pkgs_list_install" ] && {
		do_install__get_pkgs_state_md5sum do_install__pkgs_state_md5sum_new || { onexit; return 1; }
		[ ":$do_install__pkgs_state_md5sum_new" = ":$do_install__pkgs_state_md5sum_old" ] || {
			log_ml 'reapplying package state ...' 'ru:повторное применение состояния пакетов ...'
			{
				do_install__set_pkgs_state pkgs_list_install &&
				apt_get_wrapper dselect-upgrade
			} || { onexit; return 1; }
		}
	}

	onexit
}

### END COMMON FUNCTIONS



unset -v \
	conf \
	confdir \
	dpkg_arch
program_name=$(basename -- "$0")
program_version=1.2.1
is_interactive=0
simulate_install=0
overlapping_install=0
rollback_backup_path=$HOME/${program_name}-backup


usage() {
	cat <<- EOF
	Usage: $program_name [<options>] ... [<command>] [<command_arguments>] ...

	Commands:
	  install
	  rollback
	  userconf
	  verify-pkglists
	  get-config
	  analyze-deps

	Commands for using in scripts:
	  log
	  setvar
	  remove
	  emptydir
	  mergecp
	  isdirempty
	  reset-perms-owners
	  run-parts
	  findreplace

	Options:
	  -v, --version  Output version information and exit
	  -h, --help     Display this help and exit
	EOF
}

if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
	usage; exit 0
elif [ ":$1" = :--version ] || [ ":$1" = :-v ]; then
	putv program_version
	exit 0
else while getopts '' OPT; do case $OPT in
	?) exit 1;;
esac; done; fi
shift $((OPTIND - 1))
OPTIND=1

puts test | awk -f /dev/fd/3 -- test 3<<- EOF
BEGIN { ARGC = 1 }
END {
	if(\$0 == "test" && ARGV[1] == "test") exit 10
}
EOF
[ $? -eq 10 ] || err 1 'sh/awk check error, used sh or awk implementation is incompatible'

# Required for the correct functioning of install / remove scripts that invoke
# the debcomp subcommands.
[ ":$program_name" = :debcomp ] || err 1 "incorrect script name \`$program_name': must be equal to \`debcomp'"

normalize_path "$0/.." confdir || exit 1
eawk 'BEGIN {
	if(index(ARGV[1], ":"))
		err(ml("invalid path to the configuration directory: the path contains an invalid character", "ru:некорректный путь к каталогу конфигурации: путь содержит недопустимый символ") " \":\"", 1)
}' "$confdir" || exit 1

lang=$(locale | LC_ALL=C awk '{
	if(!sub(/^[\t ]*LC_MESSAGES=/, "")) next
	if(sub(/^"/, "")) {
		if(!sub(/"$/, "")) next
	} else if(sub(/^\47/, "")) {
		if(!sub(/\47$/, "")) next
	}
	sub(/@.*/, "")
	if(tolower($0) !~ /^[A-Za-z]+(_[A-Za-z]+)?\.utf-?8$/) next
	sub(/\..*/, "")
	print $0
	exit
}')

unset -v \
	DEBCONF_DB_FALLBACK \
	DEBCONF_DB_OVERRIDE \
	DEBCONF_DB_REPLACE \
	DEBCONF_SYSTEMRC \
	DEBCONF_NONINTERACTIVE_SEEN
export DEBIAN_FRONTEND=noninteractive || exit 1

onexit() { :; }
signal_handler() {
	case $1 in
	EXIT)
		ui_mode off
		onexit || [ $EXIT_CODE -ne 0 ] || err_ml 1 'onexit handler exited with an error' 'ru:обработчик onexit завершился с ошибкой'
		;;
	*)
		ui_mode off
		log "received SIG$1"
		exit
		;;
	esac
}
signal_handler__register


[ $# -eq 0 ] && {
	script_ui_message() {
		ui_callback() {
			[ ":$ui_action" = :select ] && ui_event=exit
		}
		ui "$title - $user@$hostname" "$(
			putv "$1" | eawk '{
				print ARGV[1] $0
			} END {
				print "\n" ml("Press Enter to continue", "ru:Нажмите Enter для продолжения")
			}' "$2"
		)"
	}
	script_ui_vars_export() {
		eval "$(putv conf | eawk '{
			if(!conf_parse_line()) next
			conf_add(conf)
		} END {
			if("/prop/common/conf" in conf) {
				for(i1 = 1; i1 <= conf["/prop/common/conf", 0]; i1++)
					print "script_ui_var_common_" i1 "=" shell_escape(conf["/conf/common/" conf["/prop/common/conf", i1]])
			}
			if("/prop/components-install-order" in conf) {
				for(i1 = 1; i1 <= conf["/prop/components-install-order", 0]; i1++) {
					component_conf = "/prop/components/" conf["/prop/components-install-order", i1] "/conf"
					print "script_ui_var_component_" i1 "=" shell_escape(conf["/conf/components/" conf["/prop/components-install-order", i1]])
					if(!(component_conf in conf)) { continue }
					for(i2 = 1; i2 <= conf[component_conf, 0]; i2++)
						print "script_ui_var_component_" i1 "_" i2 "=" shell_escape(conf["/conf/components/" conf["/prop/components-install-order", i1] "/" conf[component_conf, i2]])
				}
			}
		}')"
	}

	unset -v title description
	is_interactive=1
	user=$(id -un)
	hostname=$(uname -n)
	normalize_path "$rollback_backup_path" rollback_backup_path || exit 1

	check_is_conf_dir -s || {
		title=$program_name
		message=$(
			if [ "$(id -u)" = 0 ]; then
				[ -d "/var/local/lib/$program_name/rollback" ] || eawk 'BEGIN {
					print ml("There is no installed configuration", "ru:Нет установленной конфигурации")
				}'
			else
				eawk 'BEGIN {
					print ml("Root privileges are required", "ru:Требуются привилегии root")
				}'
			fi
		)
		[ -n "$message" ] && {
			script_ui_message message
			exit 1
		}
		ui "$title - $user@$hostname" "$(eawk 'BEGIN {
			print ml("The previously installed configuration will be rolled back. Backup of the files changed since its installation will be created in the", "ru:Будет выполнен откат установленной ранее конфигурации. Резервная копия файлов, изменённых с момента её установки, будет создана в каталоге") " `" ARGV[1] "\47" ml(" directory. Are you sure you want to continue?", "ru:. Вы действительно хотите продолжить?")
		}' "$rollback_backup_path")" "$(eawk 'BEGIN {
			print "bOK"
			print "vok"
			print "q" ml("Cancel", "ru:Отмена")
			print "s"
		}')" || exit 0
		ui_mode off
		"/usr/local/bin/$program_name" rollback -y || exit 1
		exit 0
	}

	checkutil dpkg || exit 1
	get_dpkg_arch || exit 1
	conf_load || exit 1
	conf_validate 0 prop || err_ml 2 'invalid configuration' 'ru:некорректная конфигурация'

	eval "$(putv conf | eawk '{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		if("/prop/common/osrelease" in conf) {
			title = " " conf["/prop/common/osrelease"]
			while(match(title, / [a-z]/))
				title = \
					substr(title, 1, RSTART) \
					toupper(substr(title, RSTART + 1, 1)) \
					substr(title, RSTART + 2)
		} else title = ""
		if("/prop/common/name" in conf) {
			if(title != "") title = " (" ml("for", "ru:для") title ")"
			title = conf["/prop/common/name"] title
		} else if(title != "")
			title = ml("Configuration for", "ru:Конфигурация для") title
		else
			title = ARGV[1]
		print "title=" shell_escape(title)
		if("/prop/common/description" in conf)
			print "description=" shell_escape(conf["/prop/common/description"])
	}' "$program_name")"

	check_os_release 1
	check_os_arch 1
	message=$(
		[ -n "$check_os_release__errors" ] &&
			putv check_os_release__errors
		[ -n "$check_os_arch__errors" ] &&
			putv check_os_arch__errors
	)
	[ -n "$message" ] &&
		script_ui_message message '- '
	while :; do
		ui_callback() {
			[ -z "$ui_var_name" ] || { [ -n "$ui_event" ] && [ ":$ui_event" != :edit_complete ]; }
			set $? '
				function get_conf_key_by_var_name(var_name, result_arr,    splitted) {
					result_arr["key"] = result_arr["component"] = ""
					if(!sub(/^script_ui_var_/, "", var_name) || var_name !~ /^(common_[1-9][0-9]*|component_[1-9][0-9]*(_[1-9][0-9]*)?)$/) return 0
					split(var_name, splitted, "_")
					if(splitted[1] == "common")
						result_arr["key"] = "/conf/common/" conf["/prop/common/conf", splitted[2]]
					else if(splitted[1] == "component") {
						result_arr["component"] = conf["/prop/components-install-order", splitted[2]]
						if(splitted[3] == "")
							result_arr["key"] = "/conf/components/" result_arr["component"]
						else
							result_arr["key"] = "/conf/components/" result_arr["component"] "/" conf["/prop/components/" result_arr["component"] "/conf", splitted[3]]
					}
					return 1
				}
				{
					if(!conf_parse_line()) next
					conf_add(conf)
				}'
			if [ $ui_init -eq 1 ] || [ $1 -eq 1 ]; then
				[ $1 -eq 1 ] && {
					if [ ":$ui_event" = :edit_complete ]; then
						ui_value_l=$ui_value_l$ui_value_r
						unset -v ui_value_r
					else
						eval "ui_value_l=\$$ui_var_name"
					fi
					conf=$(putv conf | eawk "$2"'END {
						if(get_conf_key_by_var_name(ARGV[1], result))
							conf[result["key"]] = ARGV[2]
						print result["key"]
						print result["component"]
						conf_dump(conf)
					}' "$ui_var_name" "$ui_value_l")
					conf_affected_key=$(
						putv conf | LC_ALL=C awk 'NR == 1 { print $0; exit }'
					)
					conf_validate__affected_component=$(
						putv conf | LC_ALL=C awk 'NR == 2 { print $0; exit }'
					)
					conf=$(
						putv conf | LC_ALL=C awk 'NR > 2 { print $0 }'
					)
				}
				conf_validate 1 conf
				[ -n "$conf_validate__errors" ] && {
					ui_event=exit
					return
				}
				[ $1 -eq 1 ] && {
					[ ":$ui_event" = :edit_complete ] &&
					ui_value_l=$(putv conf | eawk "$2"'END {
						print conf[ARGV[1]]
					}' "$conf_affected_key")
				}
				script_ui_vars_export
				ui_menu=$(putv conf | eawk '
				function put_ui_elem(prop_spec_key, var_name,    i, ui_elem, option_key) {
					if(conf[prop_spec_key "/type"] == "select") {
						if(add_indent == 1) print "t"
						print "t" conf[prop_spec_key "/name"] ":"
					} else {
						if( \
							conf[prop_spec_key "/type"] == "string" || \
							conf[prop_spec_key "/type"] == "integer" || \
							conf[prop_spec_key "/type"] == "float" \
						) {
							if(prop_spec_key "/hidden" in conf && conf[prop_spec_key "/hidden"] + 0)
								ui_elem = "p"
							else
								ui_elem = "i"
						}
						else if(conf[prop_spec_key "/type"] == "boolean")
							ui_elem = "c"
						if(add_indent == 2) print "t"
						add_indent = 1
						print ui_elem var_name ":" conf[prop_spec_key "/name"] (ui_elem == "i" || ui_elem == "p" ? ":" : "")
					}
					if(prop_spec_key "/description" in conf)
						print "d" conf[prop_spec_key "/description"]
					if(conf[prop_spec_key "/type"] == "select") {
						for(i = 1; i <= conf[prop_spec_key "/options", 0]; i++) {
							option_key = prop_spec_key "/options/" conf[prop_spec_key "/options", i]
							print "r" var_name ":" conf[option_key "/name"]
							print "v" conf[prop_spec_key "/options", i]
							if(option_key "/description" in conf)
								print "d" conf[option_key "/description"]
						}
						add_indent = 2
					}
				}
				{
					if(!conf_parse_line()) next
					conf_add(conf)
				} END {
					if( \
						"/prop/common/conf" in conf || \
						"/prop/components" in conf \
					) {
						print "h" ml("Configurations management", "ru:Управление конфигурациями")
						print "b" ml("Load preset...", "ru:Загрузить пресет...")
						print "vload_preset"
						print "b" ml("Save preset...", "ru:Сохранить пресет...")
						print "vsave_preset"
						print "b" ml("Delete preset...", "ru:Удалить пресет...")
						print "vdelete_preset"
						print "b" ml("Load default configuration", "ru:Загрузить конфигурацию по умолчанию")
						print "vload_default_conf"
						print "b" ml("Save default configuration", "ru:Сохранить конфигурацию по умолчанию")
						print "vsave_default_conf"
						print "b" ml("Reset configuration", "ru:Сбросить конфигурацию")
						print "vreset_conf"
						if("/prop/common/conf" in conf) {
							print "t"
							print "h" ml("Сonfiguration", "ru:Конфигурация")
							add_indent = 0
							for(i1 = 1; i1 <= conf["/prop/common/conf", 0]; i1++)
								put_ui_elem("/prop/common/conf/" conf["/prop/common/conf", i1], "script_ui_var_common_" i1)
						}
						if("/prop/components" in conf) {
							print "t"
							print "h" ml("Selected components", "ru:Выбранные компоненты")
							for(i1 = 1; i1 <= conf["/prop/components-install-order", 0]; i1++) {
								component = "/prop/components/" conf["/prop/components-install-order", i1]
								print "cscript_ui_var_component_" i1 ":" conf[component "/name"]
								if(component "/description" in conf)
									print "d" conf[component "/description"]
							}
							for(i1 = 1; i1 <= conf["/prop/components-install-order", 0]; i1++) {
								component = "/prop/components/" conf["/prop/components-install-order", i1]
								component_conf = component "/conf"
								if(!(component_conf in conf && conf["/conf/components/" conf["/prop/components-install-order", i1]] + 0)) { continue }
								print "t"
								print "h" ml("Component configuration", "ru:Конфигурация компонента") " \"" conf[component "/name"] "\""
								if(component "/description" in conf)
									print "d" conf[component "/description"]
								add_indent = 0
								for(i2 = 1; i2 <= conf[component_conf, 0]; i2++)
									put_ui_elem(component_conf "/" conf[component_conf, i2], "script_ui_var_component_" i1 "_" i2)
							}
						}
						print "t\nh"
					}
					print "b" ml("Install configuration", "ru:Установить конфигурацию")
					print "vinstall"
					print "q" ml("Exit", "ru:Выход")
				}')
			fi
		}
		ui "$title - $user@$hostname" "$description" '' "$script_ui_main_cursor_pos" || {
			[ -z "$conf_validate__errors" ] && break
			script_ui_main_cursor_pos=$ui_menu_cursor_pos
			script_ui_message conf_validate__errors '- '
			continue
		}
		script_ui_main_cursor_pos=$ui_menu_cursor_pos
		script_ui_main_choice=$ui_choice
		case $script_ui_main_choice in
		load_preset|delete_preset)
			ui "$title - $user@$hostname" '' "$(
				{
					[ -d "$confdir/presets" ] && cd "$confdir/presets" &&
					find . -path './*' -prune -type f
				} | eawk '{
					print "b" substr($0, 3)
				} END {
					if(!NR) print "t" ml("No saved presets", "ru:Нет сохранённых пресетов")
					print "t"
					print "q" ml("Back", "ru:Назад")
				}'
			)" || continue
			case $script_ui_main_choice in
			load_preset)
				contents=$(
					contents=$(cat "$confdir/presets/$ui_choice") 2>&1 &&
					putv contents
				) || script_ui_message contents
				conf=$(
					putv conf | grep -v ^conf/
					putv contents | eawk '{
						if(!conf_parse_line()) next
						conf_add(conf, "conf/" conf_key, conf_value)
					} END {
						conf_dump(conf)
					}'
				)
				;;
			delete_preset)
				message=$({
					rm -f "$confdir/presets/$ui_choice" &&
					{ ! isdirempty "$confdir/presets" || rmdir "$confdir/presets"; }
				} 2>&1) ||
					script_ui_message message
				;;
			esac
			;;
		save_preset)
			while :; do
				ui "$title - $user@$hostname" '' "$(
					{
						[ -d "$confdir/presets" ] && cd "$confdir/presets" &&
						find . -path './*' -prune -type f
					} | eawk 'BEGIN {
						print "iscript_ui_preset_name:" ml("Preset name", "ru:Имя пресета") ":"
						print "b" ml("Save", "ru:Сохранить")
						print "v"
						print "t"
					} {
						print "b" substr($0, 3)
					} END {
						if(NR) print "t"
						print "q" ml("Back", "ru:Назад")
					}'
				)" && {
					if [ -n "$ui_choice" ]; then
						script_ui_preset_name=$ui_choice
					else
						message=$(eawk 'BEGIN {
							if(ARGV[1] == "")
								print ml("No preset name specified", "ru:Не указано имя пресета")
							else if(ARGV[1] == "." || ARGV[1] == ".." || index(ARGV[1], "/"))
								print ml("Invalid preset name", "ru:Некорректное имя пресета") " \"" ARGV[1] "\""
							else exit 0
							exit 1
						}' "$script_ui_preset_name") || {
							script_ui_message message
							continue
						}
					fi
					message=$({
						[ -d "$confdir/presets" ] || mkdir "$confdir/presets"
					} && putv conf | eawk '{
						if(!conf_parse_line()) next
						conf_add(conf)
					} END {
						conf_dump(conf, "/conf", 1)
					}' > "$confdir/presets/$script_ui_preset_name") || {
						script_ui_message message
						continue
					}
				}
				unset -v script_ui_preset_name
				break
			done
			;;
		load_default_conf|reset_conf)
			conf_load $([ ":$script_ui_main_choice" = :reset_conf ] && echo 1) || exit 1
			conf_validate 0 prop || err_ml 2 'invalid configuration' 'ru:некорректная конфигурация'
			conf_validate 1 conf
			[ -n "$conf_validate__errors" ] && {
				script_ui_message conf_validate__errors
				continue
			}
			;;
		save_default_conf)
			message=$({
				putv conf | eawk '{
					if(!conf_parse_line()) next
					conf_add(conf)
				} END {
					conf_dump(conf, "/conf", 1)
				}' > "$confdir/config"
			} 2>&1) || {
				script_ui_message message
				continue
			}
			message=$(eawk 'BEGIN { print ml("Configuration saved", "ru:Конфигурация сохранена") }')
			script_ui_message message
			;;
		install)
			ui "$title - $user@$hostname" "$([ -d "/var/local/lib/$program_name/rollback" ]; eawk 'BEGIN {
				ORS = ""
				print ml("The current system configuration will be changed.", "ru:Текущая конфигурация системы будет изменена.")
				if(!ARGV[2])
					print ml(" After rolling back the previously installed configuration, a backup of the files changed since its installation will be created in the", "ru: После отката установленной ранее конфигурации резервная копия файлов, изменённых с момента её установки, будет создана в каталоге") " `" ARGV[1] "\47" ml(" directory.", "ru:.")
				print ml(" Are you sure you want to continue?", "ru: Вы действительно хотите продолжить?")
			}' "$rollback_backup_path" $?)" "$(eawk 'BEGIN {
				print "coverlapping_install:" ml("Do not remove already installed packages", "ru:Не удалять уже установленные пакеты")
				print "d" ml("Do not delete already installed packages and do not change their labels from manual to auto. This may cause conflicts between packages, in which case the installation will be canceled.", "ru:Не удалять уже установленные пакеты и не менять их маркировки с manual на auto. Это может повлечь за собой конфликты между пакетами, в таком случае установка будет отменена.")
				print "t"
				print "bOK"
				print "vinstall"
				print "b" ml("Show operations that will be performed on packages without making changes to the system", "ru:Показать операции, которые будут выполнены с пакетами, без внесения изменений в систему")
				print "vsimulate_install"
				print "q" ml("Cancel", "ru:Отмена")
				print "s"
			}')" || continue
			message=$(
				[ "$(id -u)" = 0 ] ||
					eawk 'BEGIN { print ml("root privileges are required", "ru:требуются привилегии root") }'
				[ -n "$check_os_release__errors" ] &&
					putv check_os_release__errors
				[ -n "$check_os_arch__errors" ] &&
					putv check_os_arch__errors
			)
			[ -n "$message" ] && {
				script_ui_message message '- '
				continue
			}
			ui_mode off
			case $ui_choice in
			simulate_install)
				simulate_install=1
				do_install || err_operation_failed
				simulate_install=0
				wait_user
				continue
				;;
			esac
			do_install || err_operation_failed 1
			exit 0
			;;
		esac
	done
	exit 0
}

case $1 in
install)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... install [<options>] ...

		Installs the configuration to the system.

		Options:
		  -y          Do not request confirmation. This option is only
		              meaningful when the -s option is omitted.
		  -o          Overlapping installation: do not remove already installed
		              packages and do not change their marks from manual to
		              auto. This may cause conflicts between packages, in which
		              case the installation will be canceled.
		  -s          Show operations that will be performed on packages without
		              making changes to the system
		  -h, --help  Display this help and exit
		EOF
	}

	no_confirm=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts ys OPT; do case $OPT in
		y) no_confirm=1;;
		o) overlapping_install=1;;
		s) simulate_install=1;;
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 0 ] || err_usage 'invalid number of arguments'

	{
		check_is_conf_dir &&
		checkutil dpkg
	} || exit 1

	[ $simulate_install -eq 0 ] && [ $no_confirm -eq 0 ] && {
		eawk 'BEGIN {
			print ml("The configuration will be installed from the", "ru:Будет выполнена установка конфигурации из каталога") " `" ARGV[1] "\47" ml(" directory.", "ru:.")
		}' "$confdir"
		wait_user -c || exit 1
	}

	get_dpkg_arch || exit 1
	conf_load || exit 1
	conf_validate 0 prop || err_ml 2 'invalid configuration' 'ru:некорректная конфигурация'
	conf_validate 0 conf || err_ml 1 'invalid configuration' 'ru:некорректная конфигурация'
	do_install || err_operation_failed 1
	;;
rollback)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... rollback [<options>] ...

		Rollback a previously installed system configuration.
		Note: previously installed packages will not be removed.

		Options:
		  -y          Do not request confirmation.
		  -L          Do not get a lock. This option is intended for internal
		              use only and is not recommended to be used manually.
		  -h, --help  Display this help and exit
		EOF
	}

	unset -v PREPDIR
	no_confirm=0
	no_lock=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts yL OPT; do case $OPT in
		y) no_confirm=1;;
		L) no_lock=1;;
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 0 ] || err_usage 'invalid number of arguments'

	{
		check_is_root &&
		checkutil md5sum readlink &&
		check_gnu_coreutils cp chmod chown &&
		sanitize_scripts_env &&
		get_env_path_extended &&
		normalize_path "$rollback_backup_path" rollback_backup_path
	} || exit 1

	[ $no_confirm -eq 0 ] && {
		eawk 'BEGIN {
			print ml("The previously installed configuration will be rolled back.", "ru:Будет выполнен откат установленной ранее конфигурации.")
		}' "$1"
		wait_user -c || exit 1
	}

	onexit() {
		set 0
		rm -rf "/var/local/lib/$program_name/tmp" || set 1
		[ -d "$rollback_backup_path" ] && {
			[ -d "$rollback_backup_path/files" ] && isdirempty "$rollback_backup_path/files" && {
				rmdir "$rollback_backup_path/files" || set 1
			}
			if isdirempty "$rollback_backup_path"; then
				rmdir "$rollback_backup_path" || set 1
			else
				log "$(eawk 'BEGIN {
					print ml("a backup is created in the directory", "ru:создана резервная копия в каталоге") " `" ARGV[1] "\47"
				}' "$rollback_backup_path")"
			fi
		}
		[ $no_lock -eq 1 ] || release_lock "/var/local/lib/$program_name/lock" || set 1
		isdirempty "/var/local/lib/$program_name" && {
			rmdir "/var/local/lib/$program_name" || set 1
		}
		onexit() { :; }
		return $1
	}

	[ $no_lock -eq 1 ] || {
		mkvardir &&
		get_lock "/var/local/lib/$program_name/lock" 1 1
	} || exit 1
	[ -d "/var/local/lib/$program_name/rollback" ] ||
		err 1 "directory \`/var/local/lib/$program_name/rollback' does not exist, nothing to rollback"

	[ -f "/var/local/lib/$program_name/rollback/version" ] && {
		last_major_version=$(cat "/var/local/lib/$program_name/rollback/version") || exit 1
		last_major_version=${last_major_version%%.*}
		[ ":$last_major_version" = ":${program_version%%.*}" ] ||
			err 1 "$(eawk 'BEGIN {
				print ml("incompatible", "ru:несовместимая версия") " " ARGV[1] " " ml("version: requires version", "ru:: требуется версия") " " ARGV[2] ".x.x " ml("instead of the current", "ru:вместо текущей") " " ARGV[3]
			}' "$program_name" "$last_major_version" "$program_version")"
	}
	conf=$(cat "/var/local/lib/$program_name/rollback/config") || exit 1

	{ [ -h "$rollback_backup_path" ] || [ -e "$rollback_backup_path" ]; } && {
		i=1; while [ -h "$rollback_backup_path.$i" ] || [ -e "$rollback_backup_path.$i" ]; do
			i=$((i + 1))
		done
		mv -f "$rollback_backup_path" "$rollback_backup_path.$i" || exit 1
	}
	mkdir -p "$rollback_backup_path/files" || exit 1

	putv conf | eawk '{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		for(i = 1; i <= conf["/components", 0]; i++)
			print "components/" conf["/components", i]
		if("/common" in conf)
			print "common"
	}' | while gets component; do
		rollback_path=/var/local/lib/$program_name/rollback/$component
		[ -d "$rollback_path" ] || continue
		log "$(eawk 'BEGIN {
			print ml("rolling back configuration of the component", "ru:откат конфигурации компонента") " `" ARGV[1] "\47 ..."
		}' "$component")"
		(
			cd "$rollback_path" || exit
			eval "$(
				putv conf | eawk '{
					if(!conf_parse_line()) next
					conf_add(conf)
				} END {
					for(i = 1; i <= conf["/" ARGV[1], 0]; i++) {
						if(conf["/" ARGV[1], i] !~ /^[a-z_][a-z0-9_]*$/)
							err("invalid key name `" ARGV[1] "/" conf["/" ARGV[1], i] "\47: the key name must match the regular expression `^[a-z_][a-z0-9_]*$\47", 1)
						print "export CONF_" toupper(conf["/" ARGV[1], i]) "=" shell_escape(conf["/" ARGV[1] "/" conf["/" ARGV[1], i]]) " || exit"
					}
				}' "$component" || puts 'exit 1'
			)"
			unset -v VARFILE
			! [ -f vars ] || export VARFILE="$rollback_path/vars" || exit
			export \
				PATH="$env_path_extended" \
				CONFDIR="$confdir" \
				COMPONENT="$component" \
				TEMP="/var/local/lib/$program_name/tmp" \
				TMP="/var/local/lib/$program_name/tmp" \
				TMPDIR="/var/local/lib/$program_name/tmp" || exit
			[ -f prerm ] && {
				mkvardir tmp || exit
				SCRIPT_NAME=prerm ./prerm < /dev/null ||
				err 1 "$(eawk 'BEGIN {
					print ml("script", "ru:скрипт") " `prerm\47 " ml("completed with error, exit code:", "ru:завершился с ошибкой, код завершения:") " " ARGV[1]
				}' $?)"
				rm -rf prerm "/var/local/lib/$program_name/tmp" || exit
			}
			rollback_rm "$component" || exit
			! [ -d backup ] || (
				trap '' $SIGNALS
				mergecp backup / "$rollback_backup_path/files" && rm -rf backup
			) || exit
			[ -f postrm ] && {
				mkvardir tmp || exit
				SCRIPT_NAME=postrm ./postrm < /dev/null ||
				err 1 "$(eawk 'BEGIN {
					print ml("script", "ru:скрипт") " `postrm\47 " ml("completed with error, exit code:", "ru:завершился с ошибкой, код завершения:") " " ARGV[1]
				}' $?)"
				rm -rf postrm "/var/local/lib/$program_name/tmp" || exit
			}
			rm -f vars
			true
		) || exit
		rmdir "$rollback_path" || exit
	done || exit 1

	rm -rf "/var/local/lib/$program_name/rollback" || exit
	[ "$confdir" = /usr/local/bin ] && {
		rm -f -- "$0" || exit 1
	}
	log_ml 'configuration rollback successfully completed' 'ru:откат конфигурации успешно выполнен'
	;;
userconf)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... userconf [<options>] ... <confname>

		Applies configuration located in the /etc/$program_name/userconf/<confname>
		directory to the current user. Files and directories located in the
		/etc/$program_name/userconf/<confname>/skel directory are copied to the user
		home directory, replacing the existing ones. The replaced files are
		saved to the ~/${program_name}-userconf-backup directory. Before and after
		copying, scripts are executed from the
		/etc/$program_name/userconf/<confname>/preinst.d and
		/etc/$program_name/userconf/<confname>/postinst.d directories, respectively.
		After applying the configuration, a file
		~/.$program_name/userconf/installed/<confname> will be created, which should
		be used to prevent the configuration from being applied again.

		Environment variables available in scripts:
		  SCRIPT_NAME  Name of the script with the directory containing it,
		               e.g. "preinst.d/common".
		  HOME         Path to the user home directory.
		  UID          Effective user ID.
		  USER         User name.
		  CONF_NAME    Configuration name.
		  CONF_PATH    Path to the configuration directory.
		  BACKUP_PATH  Path to the backup directory.

		Example of the /etc/profile.d/${program_name}-userconf.sh file:
		[ -e ~/.$program_name/userconf/installed/common ] || $program_name userconf common

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts '' OPT; do case $OPT in
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || err_usage 'invalid number of arguments'

	{
		check_gnu_coreutils cp chmod chown &&
		get_env_path_extended
	} || exit 1

	[ -n "$HOME" ] || err 1 'the HOME environment variable is empty'
	cd -- "$HOME" || exit 1
	HOME=$PWD
	[ "$HOME" = / ] && err 1 "the environment variable HOME cannot be equal to \`/'"
	PATH=$env_path_extended
	{ UID=$(id -u) && [ -n "$UID" ]; } || err 1 'unable to get UID'
	{ USER=$(id -un) && [ -n "$USER" ]; } || err 1 'unable to get user name'
	{ [ ":$1" = :. ] || [ ":$1" = :.. ] || expr ":$1" : ':.*/' > /dev/null; } &&
		err 1 "invalid configuration name: \`$1'"
	CONF_NAME=$1
	CONF_PATH=/etc/$program_name/userconf/$1
	BACKUP_PATH=$HOME/${program_name}-userconf-backup
	export \
		USERCONF=1 \
		HOME PATH UID USER \
		CONF_NAME CONF_PATH BACKUP_PATH || exit 1

	[ -d "$CONF_PATH" ] ||
		err 1 "$(eawk 'BEGIN {
			print ml("directory", "ru:каталог") " `" ARGV[1] "\47 " ml("does not exist", "ru:не существует")
		}' "$CONF_PATH")"
	[ -e ~/".$program_name/userconf/installed/$CONF_NAME" ] &&
		err 1 "$(eawk 'BEGIN {
			print ml("configuration", "ru:конфигурация") " `" ARGV[1] "\47 " ml("was applied previously", "ru:была применена ранее")
		}' "$CONF_NAME")"
	log "$(eawk 'BEGIN {
		print ml("applying user configuration", "ru:применение пользовательской конфигурации") " `" ARGV[1] "\47 ..."
	}' "$CONF_NAME")"
	[ -d ~/".$program_name/userconf" ] || mkdir -p -- ~/".$program_name/userconf" || exit 1

	onexit() {
		set 0
		[ -d "$BACKUP_PATH" ] && {
			if isdirempty "$BACKUP_PATH"; then
				rmdir "$BACKUP_PATH" || set 1
			else
				log "$(eawk 'BEGIN {
					print ml("a backup is created in the directory", "ru:создана резервная копия в каталоге") " `" ARGV[1] "\47"
				}' "$BACKUP_PATH")"
			fi
		}
		release_lock ~/".$program_name/lock" || set 1
		{ [ $EXIT_CODE -eq 0 ] && [ $1 -eq 0 ]; } ||
			err "$(eawk 'BEGIN {
				print ml("applying user configuration", "ru:применение пользовательской конфигурации") " `" ARGV[1] "\47 " ml("failed", "ru:завершилось с ошибкой")
			}' "$CONF_NAME")"
		onexit() { :; }
		return $1
	}

	get_lock ~/".$program_name/lock" 1 1 || exit 1

	{ [ -h "$BACKUP_PATH" ] || [ -e "$BACKUP_PATH" ]; } && {
		i=1; while [ -h "$BACKUP_PATH.$i" ] || [ -e "$BACKUP_PATH.$i" ]; do
			i=$((i + 1))
		done
		mv -f "$BACKUP_PATH" "$BACKUP_PATH.$i" || exit 1
	}
	mkdir -p "$BACKUP_PATH" || exit 1

	! [ -d "$CONF_PATH/preinst.d" ] ||
		run_parts "$CONF_PATH/preinst.d" 'export "SCRIPT_NAME=${PWD##*/}${0#.}" || interrupt' || exit 1

	! [ -d "$CONF_PATH/skel" ] ||
		mergecp "$CONF_PATH/skel" "$HOME" "$BACKUP_PATH" || exit 1

	! [ -d "$CONF_PATH/postinst.d" ] ||
		run_parts "$CONF_PATH/postinst.d" 'export "SCRIPT_NAME=${PWD##*/}${0#.}" || interrupt' || exit 1

	{
		mkdir ~/".$program_name/userconf/installed" &&
		touch ~/".$program_name/userconf/installed/$CONF_NAME"
	} || exit 1
	;;
verify-pkglists)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... verify-pkglists [<options>] ...

		Validates package lists of all components. If the -f option is specified,
		it automatically fixes inconsistencies in packages lists.

		Options:
		  -f          Automatically fix inconsistencies in packages lists. Files
		              containing errors will be saved with *.old extension.
		  -h, --help  Display this help and exit
		EOF
	}

	autofix_errors=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts f OPT; do case $OPT in
		f) autofix_errors=1;;
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 0 ] || err_usage 'invalid number of arguments'

	{
		check_is_conf_dir &&
		checkutil apt-cache apt-get dpkg
	} || exit 1

	{ get_dpkg_arch && pkgs_list_load all '' 1 "$autofix_errors"; } || exit 1
	;;
get-config)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... get-config

		Displays the current configuration.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts '' OPT; do case $OPT in
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 0 ] || err_usage 'invalid number of arguments'

	{
		check_is_conf_dir &&
		checkutil dpkg &&
		get_dpkg_arch &&
		conf_load
	} || exit 1
	conf_validate 0 prop || exit 2
	exit_code=0
	conf_validate 0 conf || exit_code=1
	putv conf | eawk '{
		if(!conf_parse_line()) next
		conf_add(conf)
	} END {
		conf_dump(conf, "/conf", 1)
	}' || exit_code=1
	exit $exit_code
	;;
analyze-deps)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... analyze-deps [<options>] ... [<package>] ...

		Analyzes the dependencies of the specified packages and outputs a list
		of packages for use in component configuration, or as a tree if the -t
		option is specified.

		Options:
		  -r           Read the names of excluded packages from standard input.
		               All listed packages and their hard dependencies will be
		               excluded recursively. Package names are read line-by-line
		               line-by-line, and all words except the first are ignored.
		               Word separators are substrings that match the
		               regular expression "[\t ]+".
		  -e PACKAGES  Exclude packages listed in the PACKAGES argument. The
		               listed packages must be separated by substrings that
		               match the regular expression "[\n\t ]+".
		  -a           Output all hard dependencies. By default, hard
		               dependencies that not have any soft dependencies in their
		               dependency chains are not output. This option is only
		               meaningful in conjunction with the -t option.
		  -t           Output the dependency tree
		  -d           Output short descriptions of packages. This option is
		               only meaningful in conjunction with the -t option.
		  -p           Use pager
		  -h, --help   Display this help and exit
		EOF
	}

	unset -v excluded_packages
	read_excluded_packages=0
	output_all_deps=0
	tree_view=0
	output_pkgs_descrs=0
	use_pager=0
	stdout_is_tty=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else while getopts re:atdp OPT; do case $OPT in
		r) read_excluded_packages=1;;
		e) excluded_packages=$OPTARG;;
		a) output_all_deps=1;;
		t)
			tree_view=1
			[ -t 1 ] && stdout_is_tty=1
			;;
		d) output_pkgs_descrs=1;;
		p)
			[ -t 1 ] && {
				checkutil less || exit 1
				use_pager=1
				stdout_is_tty=1
			}
			;;
		?) exit 1;;
	esac; done; fi
	shift $((OPTIND - 1))
	OPTIND=1

	checkutil apt-mark dpkg || exit 1

	get_dpkg_arch || exit 1
	exit_code=0
	buf=$(
		{
			[ $read_excluded_packages -eq 1 ] && sed -n '/^$/!p'
			puts
			putv excluded_packages | sed -n '/^$/!p'
			puts
			apt-mark showmanual | sed -n '/^$/!p'
			puts
			cat /var/lib/dpkg/status
		} | eawk '
			function common_err(message) {
				err(message)
				exit_code = 1
			}
			function add_dep_raw(pkg_parent, pkg_child, is_hard, is_selective) {
				pkgs_deps_raw[0]++
				pkgs_deps_raw[pkgs_deps_raw[0], 1] = pkg_parent
				pkgs_deps_raw[pkgs_deps_raw[0], 2] = pkg_child
				if(is_hard)
					pkgs_deps_raw[pkgs_deps_raw[0], 3] = is_hard
				if(is_selective)
					pkgs_deps_raw[pkgs_deps_raw[0], 4] = is_selective
			}
			function add_dep(pkg_parent, pkg_child, is_hard,    is_dep_exist) {
				if(pkg_parent == pkg_child) return
				is_dep_exist = pkg_parent SUBSEP pkg_child in pkgs_deps_all
				if(!is_dep_exist || !is_hard)
					pkgs_deps_all[pkg_parent, pkg_child] = is_hard
				if(is_dep_exist) return
				pkgs_deps[pkg_parent, ++pkgs_deps[pkg_parent]] = pkg_child
				pkgs_for[pkg_child, ++pkgs_for[pkg_child]] = pkg_parent
			}
			function process_pkgdb_fields(    pkg, i, j, splitted, not_soft_deps, pos) {
				split_flip(f["status"], splitted)
				if(check_pkgname(f["package"], 0, 1) && ("installed" in splitted)) {
					pkg = f["package"]
					if(f["architecture"] != "all" && f["architecture"] != dpkg_arch) {
						pkg = pkg ":" f["architecture"]
						foreign_archs[f["architecture"]] = ""
					}
					if(f["multi-arch"] == "" || f["multi-arch"] == "same")
						pkgs_all[pkg] = 0
					else if(f["multi-arch"] == "allowed")
						pkgs_all[pkg] = 1
					else if(f["multi-arch"] == "foreign")
						pkgs_all[pkg] = 2
					if(output_pkgs_descrs) {
						pkgs_descr[pkg] = f["description"]
						pos = index(pkgs_descr[pkg], "\n")
						if(pos) pkgs_descr[pkg] = substr(pkgs_descr[pkg], 1, pos - 1)
						if(pkgs_descr[pkg] == "") delete pkgs_descr[pkg]
					}
					process_pkgs_list(f["provides"], splitted, 1)
					for(i = 1; i <= splitted[0]; i++) {
						sub(/:[^:]+$/, "", splitted[i, 1])
						if(splitted[i, 1] == f["package"]) { continue }
						pkgs_virtual[splitted[i, 1]]
						pkgs_virtual_deps[splitted[i, 1], ++pkgs_virtual_deps[splitted[i, 1]]] = pkg
					}
					process_pkgs_list(f["depends"] "," f["pre-depends"], splitted)
					for(i = 1; i <= splitted[0]; i++) {
						if(splitted[i, 0] > 1) {
							for(j = 1; j <= splitted[i, 0]; j++) {
								add_dep_raw(pkg, splitted[i, j], 0, 1)
								not_soft_deps[splitted[i, j]] = ""
							}
						} else {
							add_dep_raw(pkg, splitted[i, 1], 1)
							not_soft_deps[splitted[i, 1]] = ""
						}
					}
					process_pkgs_list(f["recommends"] "," f["suggests"], splitted, 1)
					for(i = 1; i <= splitted[0]; i++) {
						if(!(splitted[i, 1] in not_soft_deps))
							add_dep_raw(pkg, splitted[i, 1], 0)
					}
				}
			}
			function analyze_deps(    pkg_check, i, j, pkg_parent, pkg_child, pkg_virtual, pkg_virtual_dbname, is_hard, is_selective, suitable_dep, check_archs) {
				if(pkg_check != "") {
					if(excluded_pkgs_count) {
						if(pkg_check in pkgs_included) return 1
					} else if(pkg_check in pkgs_all) return 1
					return 0
				}
				split("", pkgs_excluded, ":")
				split("", pkgs_deps_all, ":")
				split("", pkgs_deps, ":")
				split("", pkgs_for, ":")
				split("", pkgs_selective_hard_deps, ":")
				for(i = 1; i <= pkgs_deps_raw[0]; i++) {
					split_pkg_name_arch(pkgs_deps_raw[i, 1], pkg_parent, dpkg_arch)
					split_pkg_name_arch(pkgs_deps_raw[i, 2], pkg_child)
					if(pkg_child["arch"] == "all") pkg_child["arch"] = dpkg_arch
					is_hard = i SUBSEP 3 in pkgs_deps_raw && pkgs_deps_raw[i, 3]
					is_selective = i SUBSEP 4 in pkgs_deps_raw && pkgs_deps_raw[i, 4]
					if(pkg_child["name"] in pkgs_virtual) {
						for(j = 1; j <= pkgs_virtual_deps[pkg_child["name"]]; j++) {
							pkg_virtual_dbname = pkgs_virtual_deps[pkg_child["name"], j]
							if(!analyze_deps(pkg_virtual_dbname)) { continue }
							if(pkg_child["arch"] == "any") {
								if(!(pkg_virtual_dbname in pkgs_all && pkgs_all[pkg_virtual_dbname] == 1)) { continue }
							} else if(!(pkg_virtual_dbname in pkgs_all && pkgs_all[pkg_virtual_dbname] == 2)) {
								split_pkg_name_arch(pkg_virtual_dbname, pkg_virtual, dpkg_arch)
								if(pkg_virtual["arch"] != (pkg_child["arch"] == "" ? pkg_parent["arch"] : pkg_child["arch"])) { continue }
							}
							if(is_hard) is_selective = 1
							is_hard = 0
							add_dep(pkgs_deps_raw[i, 1], pkg_virtual_dbname, 0)
							if(is_selective)
								pkgs_selective_hard_deps[pkgs_deps_raw[i, 1], pkg_virtual_dbname] = ""
						}
					}
					if(pkg_child["arch"] == "" || pkg_child["arch"] == "any" || pkg_child["arch"] == dpkg_arch)
						suitable_dep = pkg_child["name"]
					else
						suitable_dep = pkg_child["name"] ":" pkg_child["arch"]
					if( \
						( \
							!analyze_deps(suitable_dep) || \
							(pkg_child["arch"] == "" && pkg_parent["arch"] != dpkg_arch && !(suitable_dep in pkgs_all && pkgs_all[suitable_dep] == 2)) || \
							(pkg_child["arch"] == "any" && !(suitable_dep in pkgs_all && pkgs_all[suitable_dep] == 1)) \
						) && \
						(pkg_child["arch"] == "" || pkg_child["arch"] == "any") \
					) {
						if(!is_hard) suitable_dep = ""
						split("", check_archs, ":")
						if(pkg_parent["arch"] != dpkg_arch)
							check_archs[++check_archs[0]] = pkg_parent["arch"]
						for(j in foreign_archs) {
							if(j != pkg_parent["arch"])
								check_archs[++check_archs[0]] = j
						}
						for(j = 1; j <= check_archs[0]; j++) {
							if(!analyze_deps(pkg_child["name"] ":" check_archs[j])) { continue }
							if(pkg_child["arch"] == "any") {
								if(!(pkg_child["name"] ":" check_archs[j] in pkgs_all && pkgs_all[pkg_child["name"] ":" check_archs[j]] == 1)) { continue }
							} else if(pkg_parent["arch"] != check_archs[j] && !(pkg_child["name"] ":" check_archs[j] in pkgs_all && pkgs_all[pkg_child["name"] ":" check_archs[j]] == 2)) { continue }
							suitable_dep = pkg_child["name"] ":" check_archs[j]
							break
						}
					}
					if(suitable_dep == "") { continue }
					add_dep(pkgs_deps_raw[i, 1], suitable_dep, is_hard)
					if(is_selective)
						pkgs_selective_hard_deps[pkgs_deps_raw[i, 1], suitable_dep] = ""
				}
				split("", pkgs_included, ":")
				excluded_pkgs_count_old = excluded_pkgs_count
				excluded_pkgs_count = 0
				for(i in pkgs_exclude) {
					pkgs_excluded[i] = ""
					excluded_pkgs_count++
				}
				for(i in pkgs_exclude_recursive) exclude_recursive(i)
				for(i = 1; i <= pkgs_root[0]; i++) {
					if(!(pkgs_root[i] in pkgs_all)) { continue }
					find_included_pkgs(pkgs_root[i])
				}
				split("", pkgs_excluded, ":")
			}
			function exclude_recursive(pkg,    i) {
				if(!(pkg in pkgs_all) || pkg in pkgs_excluded) return
				pkgs_excluded[pkg] = ""
				excluded_pkgs_count++
				for(i = 1; i <= pkgs_deps[pkg]; i++) {
					if(pkgs_deps_all[pkg, pkgs_deps[pkg, i]])
						exclude_recursive(pkgs_deps[pkg, i])
				}
			}
			function find_included_pkgs(pkg, is_hard_dep,    local_pkgs_excluded, has_soft_deps, i) {
				if(pkg in pkgs_included && (pkgs_included[pkg] || is_hard_dep))
					return pkgs_included[pkg]
				if(pkg in local_pkgs_excluded || (!is_hard_dep && pkg in pkgs_excluded)) return 0
				local_pkgs_excluded[pkg] = ""
				has_soft_deps = 0
				if(pkg in pkgs_all) {
					for(i = 1; i <= pkgs_deps[pkg]; i++) {
						if(pkgs_deps_all[pkg, pkgs_deps[pkg, i]] && !(pkg SUBSEP pkgs_deps[pkg, i] in pkgs_deps_broken) && !(pkgs_deps[pkg, i] in pkgs_all)) {
							pkgs_deps_broken[pkg, pkgs_deps[pkg, i]] = ""
							common_err(ml("package", "ru:пакет") " `" pkgs_deps[pkg, i] "\47 " ml("does not exist, but is required for package", "ru:не существует, однако требуется для пакета") " `" pkg "\47")
						}
						if(find_included_pkgs(pkgs_deps[pkg, i], pkgs_deps_all[pkg, pkgs_deps[pkg, i]], local_pkgs_excluded))
							has_soft_deps = 1
					}
				}
				if(is_hard_dep && !has_soft_deps) {
					delete local_pkgs_excluded[pkg]
					if(!(pkg in pkgs_included)) pkgs_included[pkg] = 0
				} else pkgs_included[pkg] = 1
				return pkgs_included[pkg]
			}
			function find_parent_manual_pkgs(pkg,    is_self_call, local_pkgs_manual, local_pkgs_manual_excluded, local_pkgs_excluded, i, retval) {
				local_pkgs_excluded[pkg] = ""
				if(!is_self_call && pkg in pkgs_manual)
					local_pkgs_manual_excluded[pkg] = ""
				for(i = 1; i <= pkgs_for[pkg]; i++) {
					if(!(pkgs_for[pkg, i] in pkgs_included)) { continue }
					if( \
						!(pkgs_for[pkg, i] in local_pkgs_manual_excluded) && \
						pkgs_for[pkg, i] in pkgs_manual \
					) {
						local_pkgs_manual[++local_pkgs_manual[0]] = pkgs_for[pkg, i]
						local_pkgs_manual_excluded[pkgs_for[pkg, i]] = ""
					}
					if(!(pkgs_for[pkg, i] in local_pkgs_excluded))
						find_parent_manual_pkgs(pkgs_for[pkg, i], 1, local_pkgs_manual, local_pkgs_manual_excluded, local_pkgs_excluded)
				}
				if(!is_self_call) {
					retval = ""
					for(i = 1; i <= local_pkgs_manual[0]; i++) {
						if(i != 1) retval = retval " "
						retval = retval local_pkgs_manual[i]
					}
					return retval
				}
			}
			function print_deps(pkg,    is_hard_dep, is_selective_hard_dep, is_parent_hard_dep, is_excluded, is_hive_end, pre_str, i, for_manual, has_pkgs_for, local_pkgs_deps, fmt) {
				if(tree_view) {
					printf("%s", pre_str)
					if(is_hive_end != 0 || is_hive_end != "")
						printf("%s", tc(is_parent_hard_dep ? "34" : "32") "\342\224" (is_hive_end ? "\224" : "\234") "\342\224\200" tc("0") " ")
					if(pkg in pkgs_manual) fmt = ";1"
					if(is_hard_dep) fmt = tc("34" fmt) "(%s)"
					else if(is_selective_hard_dep) fmt = tc("33" fmt) "{%s}"
					else fmt = tc("32" fmt) "%s"
					if(pkg in pkgs_manual) fmt = fmt " *"
					if(is_excluded && pkgs_included[pkg]) fmt = fmt " [...]"
					fmt = fmt tc("0")
					if(!(pkg in pkgs_all)) fmt = fmt " " tc("1;31") "!" tc("0")
					printf(fmt, pkg)
					if(pkg in pkgs_descr) printf("  # %s", pkgs_descr[pkg])
					printf("\n")
					if(is_hive_end != 0 || is_hive_end != "")
						pre_str = pre_str "" (is_hive_end ? "   " : tc(is_parent_hard_dep ? "34" : "32") "\342\224\202" tc("0") "  ")
				} else if((pkg in pkgs_manual || !is_hard_dep) && (!(pkg in pkgs_excluded) || !pkgs_excluded[pkg])) {
					printf("%s", ((pkg in pkgs_manual) ? 1 : 2) ":" pkg " " ((pkg in pkgs_manual) ? "manual" : "auto"))
					for_manual = find_parent_manual_pkgs(pkg)
					if(for_manual != "") printf(" for_manual(%s)", for_manual)
					has_pkgs_for = 0
					for(i = 1; i <= pkgs_for[pkg]; i++) {
						if(!(pkgs_for[pkg, i] in pkgs_included) || pkgs_deps_all[pkgs_for[pkg, i], pkg]) { continue }
						if(has_pkgs_for) printf(" ")
						else {
							has_pkgs_for = 1
							printf(" for(")
						}
						printf("%s", pkgs_for[pkg, i])
					}
					if(has_pkgs_for) printf(")")
					printf("\n")
					pkgs_excluded[pkg] = 1
				}
				if(is_excluded || !(pkg in pkgs_all)) return
				for(i = 1; i <= pkgs_deps[pkg]; i++) {
					if(!(pkgs_deps[pkg, i] in pkgs_included) || (!output_all_deps && !pkgs_included[pkgs_deps[pkg, i]])) { continue }
					local_pkgs_deps[++local_pkgs_deps[0], 1] = pkgs_deps[pkg, i]
					local_pkgs_deps[local_pkgs_deps[0], 2] = pkgs_deps_all[pkg, pkgs_deps[pkg, i]]
					local_pkgs_deps[local_pkgs_deps[0], 3] = pkgs_deps[pkg, i] in pkgs_excluded
					if(!(pkgs_deps[pkg, i] in pkgs_excluded)) pkgs_excluded[pkgs_deps[pkg, i]] = 0
				}
				for(i = 1; i <= local_pkgs_deps[0]; i++)
					print_deps( \
						local_pkgs_deps[i, 1], \
						local_pkgs_deps[i, 2], \
						(pkg SUBSEP local_pkgs_deps[i, 1] in pkgs_selective_hard_deps), \
						is_hard_dep, \
						local_pkgs_deps[i, 3], \
						i == local_pkgs_deps[0], \
						pre_str \
					)
			}
			BEGIN {
				output_all_deps = '"$output_all_deps"'
				tree_view = '"$tree_view"'
				stdout_is_tty = '"$stdout_is_tty"'
				output_pkgs_descrs = '"$output_pkgs_descrs"'
				dpkg_arch = ARGV[1]
				if(!tree_view) output_all_deps = 0
				is_primary_pkgs_specified = argc > 2
				pkgdb_fields["package"] = pkgdb_fields["status"] =\
				pkgdb_fields["architecture"] = pkgdb_fields["multi-arch"] =\
				pkgdb_fields["provides"] = pkgdb_fields["depends"] =\
				pkgdb_fields["pre-depends"] = pkgdb_fields["recommends"] =\
				pkgdb_fields["suggests"] = ""
				if(output_pkgs_descrs) pkgdb_fields["description"] = ""
				state = 1
				do_exclude_pkgs = 0
				excluded_pkgs_count = 0
			} {
				if(state == 1) {
					if($0 == "") { state++; next }
					if($0 ~ /^[\t\v\f\r ]*#/ || !check_pkgname($1, 1, 1)) next
					split_pkg_name_arch($1, splitted)
					if(splitted["arch"] == dpkg_arch) $1 = splitted["name"]
					pkgs_exclude_recursive[$1] = ""
					do_exclude_pkgs = 1
				} else if(state == 2) {
					if($0 == "") { state++; next }
					for(i = 1; i <= NF; i++) {
						if(!check_pkgname($i, 1, 1)) { continue }
						split_pkg_name_arch($i, splitted)
						if(splitted["arch"] == dpkg_arch) $i = splitted["name"]
						pkgs_exclude[$i] = ""
						do_exclude_pkgs = 1
					}
				} else if(state == 3) {
					if($0 == "") { state++; next }
					if($0 in pkgs_manual) next
					pkgs_manual[$0] = ""
					if(!is_primary_pkgs_specified)
						pkgs_root[++pkgs_root[0]] = $0
				} else if(state == 4) {
					if(!pkgdb_parse_line($0)) process_pkgdb_fields()
				}
			} END {
				if(pkgdb_state) process_pkgdb_fields()
				pkgdb_state = 0
				if(is_primary_pkgs_specified) {
					for(i = 2; i < argc; i++) {
						if(ARGV[i] in dup) { continue }
						pkgs_root[++pkgs_root[0]] = ARGV[i]
						dup[ARGV[i]] = ""
					}
				}
				split("", dup, ":")
				analyze_deps()
				if(do_exclude_pkgs) {
					do analyze_deps()
					while(excluded_pkgs_count != excluded_pkgs_count_old)
				}
				split("", pkgs_deps_raw, ":")
				split("", pkgs_virtual, ":")
				split("", pkgs_virtual_deps, ":")
				for(i = 1; i <= pkgs_root[0]; i++)
					pkgs_excluded[pkgs_root[i]] = ""
				for(i = 1; i <= pkgs_root[0]; i++) {
					if(!(pkgs_root[i] in pkgs_included) || (!output_all_deps && !pkgs_included[pkgs_root[i]])) { continue }
					print_deps(pkgs_root[i])
				}
				exit exit_code
			}' "$dpkg_arch" "$@"
	) || exit_code=1
	command='putv buf'
	[ $tree_view -eq 0 ] && command=$command' | LC_ALL=C sort | sed '\''s/^[^:]*://'\'
	[ $use_pager -eq 1 ] && {
		command=$command' | less -R'
		[ $tree_view -eq 1 ] && command=$command'S'
	}
	eval "$command"
	exit $exit_code
	;;
log)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... log <message> [<message_ml>]

		Outputs an information message to standard output, or an error message
		to standard error if the -e option is passed. If the <message_ml>
		argument is passed, multilingual support is used. The <message_ml>
		argument must contain strings in the "lang:message" format, separated
		by the "|" character.

		Options:
		  -e          Output passed message as an error message
		  -h, --help  Display this help and exit
		EOF
	}

	is_err_message=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts e OPT; do case $OPT in
			e) is_err_message=1;;
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || [ $# -eq 2 ] || err_usage 'invalid number of arguments'

	prefix="$SCRIPT_NAME: "
	case $SCRIPT_NAME in
	preinst|postinst|prerm|postrm)
		prefix=$COMPONENT/$prefix
		;;
	prebuild)
		prefix=$PACKAGE/DEBIAN/$prefix
		;;
	esac

	case $is_err_message$# in
	01) log "$prefix$1";;
	02) log_ml__msg_prefix=$prefix; log_ml "$1" "$2";;
	11) err "$prefix$1";;
	12) err_ml__msg_prefix=$prefix; err_ml "$1" "$2";;
	esac
	;;
setvar)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... setvar <var_name> [<var_value>]

		Saves the passed variable value to a file for later use in the "prerm"
		and "postrm" scripts. To load all stored variable values, run the
		command \`[ -z "\$VARFILE" ] || . "\$VARFILE" || exit\` in any of these
		scripts. If the <var_value> argument is not passed, the value of the
		variable is read from standard input. The command can only be called
		from the "preinst" and "postinst" scripts.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ ":$SCRIPT_NAME" = :preinst ] || [ ":$SCRIPT_NAME" = :postinst ] || err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || [ $# -eq 2 ] || err_usage 'invalid number of arguments'

	trap '' $SIGNALS
	eawk 'BEGIN {
		ORS = ""
		if(ARGV[1] !~ /^[A-Za-z_][A-Za-z0-9_]*$/)
			err("setvar: " ml("invalid variable name", "ru:некорректное имя переменной") ": `" ARGV[1] "\47", 1)
		print ARGV[1] "="
		if(argc == 3) {
			print shell_escape(ARGV[2]) "\n"
			exit
		}
		print "\47"
		while((retval = getline) > 0) {
			if(NR > 1) print "\n"
			print shell_escape($0, 1)
		}
		print "\47\n"
		if(retval < 0)
			err("setvar: " ml("unable to read value from standard input", "ru:невозможно прочитать значение со стандартного ввода") " " ARGV[1], 1)
	}' "$@" >> "/var/local/lib/$program_name/rollback/$COMPONENT/vars" || exit 1
	;;
remove|emptydir)
	subcmd=$1; shift

	if [ "$subcmd" = remove ]; then
		usage() {
			cat <<- EOF
			Usage: $program_name [<options>] ... remove <target>

			Removes the specified file or directory along with its contents,
			creating a backup if called from the "preinst" or "prerm" script.

			Options:
			  -h, --help  Display this help and exit
			EOF
		}
	else
		usage() {
			cat <<- EOF
			Usage: $program_name [<options>] ... emptydir <target>

			Removes the contents of the specified directory, creating a backup if
			called from the "preinst" or "prerm" script.

			Options:
			  -h, --help  Display this help and exit
			EOF
		}
	fi

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || err_usage 'invalid number of arguments'

	checkutil realpath || exit 1
	# Not required, because this check is performed by the calling process.
	# check_gnu_coreutils cp chmod chown || exit 1

	if [ "$subcmd" = remove ]; then
		[ -h "$1" ] || [ -e "$1" ] || exit 0
	else
		[ -d "$1" ] || err 1 "$subcmd: directory \`$1' does not exist"
	fi
	{
		normalize_path "$1" target_path &&
		normalize_path "$rollback_backup_path" rollback_backup_path
	} || exit 1
	target_path=$(realpath "$target_path" && echo .) || exit 1
	eval "target_path=$(LC_ALL=C awk -- 'BEGIN {
		if(!sub(/\n\.$/, "", ARGV[1])) exit 1
		gsub(/\47/, "\47\134\47\47", ARGV[1])
		print "\47" ARGV[1] "\47"
	}' "$target_path" || puts 'exit 1')"
	[ "$target_path" = / ] && err 1 "$subcmd: invalid operation for \`/'"

	[ "$subcmd" = emptydir ] && {
		cd "$target_path" || exit 1
		isdirempty . && exit 0
	}

	make_backup=0
	is_userconf=0
	case $SCRIPT_NAME in
	preinst|prerm)
		case $target_path in
		"/var/local/lib/$program_name/"*) ;;
		*) make_backup=1
		esac
		;;
	*)
		[ -n "$USERCONF" ] && [ ":$USERCONF" != :0 ] && {
			is_userconf=1
			case $target_path in
			"$HOME/"*) make_backup=1;;
			esac
		}
		;;
	esac

	trap '' $SIGNALS
	[ $make_backup -eq 1 ] && {
		if [ ":$SCRIPT_NAME" = :preinst ]; then
			backup_path=/var/local/lib/$program_name/rollback/$COMPONENT/backup
			old_ifs=$IFS; IFS=/
			backup_target_dir=${target_path%/*}
			unset -v dir_path
			for elem in ${backup_target_dir#/}; do
				dir_path=$dir_path/$elem
				! [ -h "$backup_path$dir_path" ] && [ -d "$backup_path$dir_path" ] && continue
				{
					mkdir "$backup_path$dir_path" &&
					chmod --reference="$dir_path" "$backup_path/$dir_path" &&
					chown --reference="$dir_path" "$backup_path/$dir_path"
				} || exit 1
			done
			IFS=$old_ifs
			cp -dfpRT "$target_path" "$backup_path$target_path" || exit 1
		else
			if [ $is_userconf -eq 1 ]; then
				backup_path=$BACKUP_PATH
				eval "backup_target_path=$(eawk 'BEGIN {
					sub("/+$", "", ARGV[1])
					home_len = length(ARGV[1])
					if(!home_len || substr(ARGV[2], 1, home_len + 1) != ARGV[1] "/") exit 1
					print shell_escape(substr(ARGV[2], home_len + 1))
				}' "$HOME" "$target_path" || puts 'exit 1')"
			else
				backup_path=$rollback_backup_path/files
				backup_target_path=$target_path
				! [ "$subcmd" = emptydir ]
				rollback_rm "$COMPONENT" "$target_path" $? || exit 1
			fi
			if [ "$subcmd" = emptydir ]; then
				if isdirempty "$target_path"; then
					make_backup=0
				else
					is_target_dir=1
					backup_target_dir=$backup_target_path
				fi
			else
				is_target_dir=0
				if [ -h "$target_path" ]; then
					backup_target_dir=${backup_target_path%/*}
				elif [ -d "$target_path" ]; then
					is_target_dir=1
					backup_target_dir=$backup_target_path
				elif [ -e "$target_path" ]; then
					backup_target_dir=${backup_target_path%/*}
				else
					make_backup=0
				fi
			fi
			[ $make_backup -eq 1 ] && {
				old_ifs=$IFS; IFS=/
				unset -v dir_path
				for elem in ${backup_target_dir#/}; do
					dir_path=$dir_path/$elem
					if [ -h "$backup_path$dir_path" ]; then
						make_backup=0; break
					elif [ -d "$backup_path$dir_path" ]; then
						continue
					elif [ -e "$backup_path$dir_path" ]; then
						make_backup=0; break
					fi
					{
						mkdir "$backup_path$dir_path" &&
						if [ $is_userconf -eq 1 ]; then
							chmod --reference="$HOME$dir_path" "$backup_path$dir_path"
						else
							chmod --reference="$dir_path" "$backup_path$dir_path" &&
							chown --reference="$dir_path" "$backup_path$dir_path"
						fi
					} || exit 1
				done
				IFS=$old_ifs
			}
			[ $make_backup -eq 1 ] && {
				if [ $is_target_dir -eq 1 ]; then
					[ "$subcmd" = emptydir ] || cd "$target_path" || exit 1
					USERCONF=$is_userconf \
					BACKUP_PATH=$backup_path$backup_target_path \
					find . ! -path . -exec sh -c '
						interrupt() { kill -INT "$PPID"; exit; }
						path=${0#.}
						{ [ -h "$BACKUP_PATH$path" ] || [ -e "$BACKUP_PATH$path" ]; } && exit
						old_ifs=$IFS; IFS=/
						target_dir=${path%/*}
						unset -v dir_path
						for elem in ${target_dir#/}; do
							dir_path=$dir_path/$elem
							if [ -h "$BACKUP_PATH$dir_path" ]; then
								exit
							elif [ -d "$BACKUP_PATH$dir_path" ]; then
								continue
							elif [ -e "$BACKUP_PATH$dir_path" ]; then
								exit
							fi
							{
								mkdir -- "$BACKUP_PATH$dir_path" &&
								chmod --reference=".$dir_path" "$BACKUP_PATH$dir_path" &&
								{ [ $USERCONF -eq 1 ] || chown --reference=".$dir_path" "$BACKUP_PATH$dir_path"; }
							} || interrupt
						done
						IFS=$old_ifs
						if ! [ -h "$0" ] && [ -d "$0" ]; then
							mkdir -- "$BACKUP_PATH$path" &&
							chmod --reference="$0" "$BACKUP_PATH$path" &&
							{ [ $USERCONF -eq 1 ] || chown --reference="$0" "$BACKUP_PATH$path"; }
						else
							cp -dfpT "$0" "$BACKUP_PATH$path"
						fi || interrupt
					' {} \;
				else
					cp -dfpT "$target_path" "$backup_path$backup_target_path"
				fi || exit 1
			}
		fi
	}
	if [ "$subcmd" = remove ]; then
		rm -rf "$target_path" || exit 1
	else
		find . -path './*' -prune -exec \
			sh -c 'rm -rf -- "$0" || kill -INT "$PPID"' {} \; || exit 1
	fi
	;;
mergecp)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... mergecp <source> <target> [<backup_path>]

		Recursively copies the source file / directory to target, overlaying the
		contents of the directories on top of each other, removing
		files or directories from the target directory if necessary. If the
		<backup_path> argument is specified, it creates a backup of all removed
		files and directories at the specified path.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 2 ] || [ $# -eq 3 ] || err_usage 'invalid number of arguments'

	# Not required, because this check is performed by the calling process.
	# check_gnu_coreutils cp chmod chown || exit 1

	if [ $# -eq 3 ]; then
		mergecp "$1" "$2" "$3"
	else
		mergecp "$1" "$2"
	fi || exit 1
	;;
isdirempty)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... isdirempty <dir>

		Checks whether the directory is empty. Returns 0 if the directory is
		empty, 1 if the directory is not empty, and 2 in case of an error.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || err_usage 'invalid number of arguments'

	isdirempty "$1"
	exit
	;;
reset-perms-owners)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... reset-perms-owners <target>

		Recursively sets permissions 755 for directories and 644 for files, sets
		root:root as the owner / group for all files and directories if executed
		with root privileges.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || err_usage 'invalid number of arguments'

	normalize_path "$1" target_path || exit 1
	[ "$target_path" = / ] && err 1 "reset-perms-owners: invalid operation for \`/'"

	reset_perms_owners "$target_path" || exit 1
	;;
run-parts)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... run-parts <directory>

		Executes all executable files from the specified directory. The exit
		code is 1 if one of the scripts completed with a non-zero exit code,
		and 2 if the specified directory does not exist or cannot be accessed.

		Options:
		  -h, --help  Display this help and exit
		EOF
	}

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts '' OPT; do case $OPT in
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -eq 1 ] || err_usage 'invalid number of arguments'

	run_parts "$1"
	exit
	;;
findreplace)
	shift

	usage() {
		cat <<- EOF
		Usage: $program_name [<options>] ... findreplace <string> <replacement> <path> ...

		Searches for <string> and replaces it with <replacement> in the
		specified files or directories. Files containing NULL bytes are ignored.

		Options:
		  -i          Case-insensitive search
		  -v          Treat value of the <replacement> argument as name of the
		              environment variable containing the string to replace the
		              search string with. Name of the environment variable must
		              match the regular expression ^[A-Z_][A-Z0-9_]*\$.
		  -h, --help  Display this help and exit
		EOF
	}

	is_case_insensitive=0
	replacement_is_var_name=0

	if [ ":$1" = :--help ] || [ ":$1" = :-h ]; then
		usage; exit 0
	else
		[ -z "$SCRIPT_NAME" ] && err_usage
		while getopts iv OPT; do case $OPT in
			i) is_case_insensitive=1;;
			v) replacement_is_var_name=1;;
			?) exit 1;;
		esac; done
	fi
	shift $((OPTIND - 1))
	OPTIND=1
	[ $# -ge 3 ] || err_usage 'invalid number of arguments'

	if [ $replacement_is_var_name -eq 1 ]; then
		LC_ALL=C awk -- 'BEGIN { if(ARGV[1] !~ /^[A-Z_][A-Z0-9_]*$/) exit 1 }' "$2" ||
			err 1 "findreplace: $(eawk 'BEGIN {
				print ml("incorrect environment variable name", "ru:некорректное имя переменной окружения") ": `" ARGV[1] "\47"
			}' "$2")"
		eval "REPLACEMENT=\$$2; unset -v $2"
	else
		REPLACEMENT=$2
	fi
	PATTERN=$1
	IS_CASE_INSENSITIVE=$is_case_insensitive
	export \
		PATTERN \
		REPLACEMENT \
		IS_CASE_INSENSITIVE || exit 1
	shift 2

	eval "set -- $(
		for arg in "$@"; do
			[ -z "$arg" ] && { puts '; false'; break; }
			normalize_path "$arg" -
		done | tr \\n ' '
	)" || err_ml 1 'findreplace: argument <path> can'\''t be an empty string' 'ru:findreplace: аргумент <path> не может быть пустой строкой'

	find "$@" -type f -exec sh -c '
		interrupt() { kill -INT "$PPID"; exit; }
		[ $(tr -dc \\0 < "$0" | wc -c) -eq 0 ] || exit
		{ trailing_newline=$(tail -c1 "$0" | wc -l) && [ -n "$trailing_newline" ]; } || interrupt
		LC_ALL=C awk -- '\''BEGIN {
			ARGC = 1; ORS = ""
			pattern = ENVIRON["PATTERN"]
			replacement = ENVIRON["REPLACEMENT"]
			is_case_insensitive = ENVIRON["IS_CASE_INSENSITIVE"] + 0
			trailing_newline = ARGV[2] + 0
			if(is_case_insensitive) pattern = tolower(pattern)
			pattern_len = length(pattern)
			has_replacements = 0
			while((retval = getline < ARGV[1]) > 0) {
				l++
				while(pos = (is_case_insensitive ? index(tolower($0), pattern) : index($0, pattern))) {
					has_replacements = 1
					if(pos != 1) ln[l] = ln[l] substr($0, 1, pos - 1)
					ln[l] = ln[l] replacement
					$0 = substr($0, pos + pattern_len)
				}
				ln[l] = ln[l] $0
			}
			close(ARGV[1])
			if(retval < 0) exit 1
			if(!has_replacements) exit 0
			for(i = 1; i <= l; i++) {
				if(i != 1) print "\n" > ARGV[1]
				print ln[i] > ARGV[1]
			}
			if(trailing_newline) print "\n" > ARGV[1]
			close(ARGV[1])
		}'\'' "$0" "$trailing_newline" || interrupt
	' {} \; || exit 1
	;;
*) err_usage;;
esac

exit 0
